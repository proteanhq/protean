<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Protean Observatory</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Lato:wght@400;600;800&family=Roboto+Mono:wght@400;500&display=swap" rel="stylesheet">
<style>
:root {
  --primary: #1D3557;
  --secondary: #457B9D;
  --accent: #E76F51;
  --success: #2A9D8F;
  --warning: #E9C46A;
  --bg: #F8F9FA;
  --surface: #FFFFFF;
  --text: #1D3557;
  --text-muted: #6C757D;
  --border: #DEE2E6;
  --font-text: 'Lato', sans-serif;
  --font-code: 'Roboto Mono', monospace;
}

@media (prefers-color-scheme: dark) {
  :root {
    --primary: #A8DADC;
    --secondary: #457B9D;
    --accent: #E76F51;
    --success: #2A9D8F;
    --warning: #E9C46A;
    --bg: #0D1B2A;
    --surface: #1B2838;
    --text: #E0E0E0;
    --text-muted: #8899AA;
    --border: #2A3A4A;
  }
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  font-family: var(--font-text);
  background: var(--bg);
  color: var(--text);
  line-height: 1.5;
}

/* Header */
.header {
  background: #1D3557;
  color: white;
  padding: 12px 24px;
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.header-left {
  display: flex;
  align-items: center;
  gap: 12px;
}

.header-left .logo {
  font-size: 18px;
  font-weight: 800;
  letter-spacing: -0.025em;
}

.header-left .subtitle {
  font-size: 13px;
  opacity: 0.7;
}

.header-right {
  display: flex;
  align-items: center;
  gap: 12px;
}

.header select {
  background: rgba(255,255,255,0.15);
  color: white;
  border: 1px solid rgba(255,255,255,0.3);
  padding: 4px 8px;
  border-radius: 4px;
  font-family: var(--font-text);
  font-size: 13px;
  cursor: pointer;
}

.header select option { color: #333; background: white; }

.btn {
  background: rgba(255,255,255,0.15);
  color: white;
  border: 1px solid rgba(255,255,255,0.3);
  padding: 4px 12px;
  border-radius: 4px;
  font-family: var(--font-text);
  font-size: 13px;
  cursor: pointer;
  transition: background 0.15s;
}

.btn:hover { background: rgba(255,255,255,0.25); }
.btn.active { background: var(--accent); border-color: var(--accent); }

/* Connection status */
.status-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  display: inline-block;
}

.status-dot.connected { background: var(--success); }
.status-dot.disconnected { background: var(--accent); }

/* Main layout */
.main {
  max-width: 1400px;
  margin: 0 auto;
  padding: 16px 24px;
  display: flex;
  flex-direction: column;
  gap: 16px;
}

/* Card */
.card {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 8px;
  overflow: hidden;
}

.card-header {
  padding: 10px 16px;
  font-size: 13px;
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.card-body { padding: 16px; }

/* Summary Metrics Bar */
.summary-bar {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 14px 20px;
  gap: 16px;
  flex-wrap: wrap;
}

.summary-metrics {
  display: flex;
  gap: 32px;
  flex-wrap: wrap;
}

.summary-metric {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.summary-metric .metric-label {
  font-size: 11px;
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.summary-metric .metric-value {
  font-family: var(--font-code);
  font-size: 22px;
  font-weight: 500;
}

.summary-metric .metric-value.good { color: var(--success); }
.summary-metric .metric-value.warn { color: #E65100; }
.summary-metric .metric-value.bad { color: var(--accent); }

.window-selector {
  display: flex;
  gap: 4px;
}

.window-btn {
  background: var(--bg);
  color: var(--text-muted);
  border: 1px solid var(--border);
  padding: 4px 12px;
  border-radius: 4px;
  font-family: var(--font-code);
  font-size: 12px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.15s;
}

.window-btn:hover { border-color: var(--secondary); color: var(--text); }
.window-btn.active {
  background: var(--secondary);
  color: white;
  border-color: var(--secondary);
}

/* Pipeline */
.pipeline {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  padding: 20px 16px;
  flex-wrap: wrap;
}

.pipeline-stage {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
  min-width: 90px;
}

.pipeline-stage .label {
  font-size: 11px;
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
}

.pipeline-stage .rate-label {
  font-size: 10px;
  color: var(--text-muted);
  font-family: var(--font-code);
  min-height: 15px;
}

.pipeline-stage .count-box {
  width: 80px;
  height: 48px;
  border-radius: 6px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-family: var(--font-code);
  font-size: 20px;
  font-weight: 500;
  transition: all 0.3s;
}

.pipeline-stage .count-box.published { background: #E8F4FD; color: var(--secondary); border: 2px solid var(--secondary); }
.pipeline-stage .count-box.handling { background: #FFF3E0; color: #E65100; border: 2px solid var(--warning); }
.pipeline-stage .count-box.done { background: #E8F5E9; color: var(--success); border: 2px solid var(--success); }
.pipeline-stage .count-box.failed { background: #FFEBEE; color: var(--accent); border: 2px solid var(--accent); }

.pipeline-arrow {
  color: var(--text-muted);
  font-size: 20px;
  margin-top: 14px;
}

@media (prefers-color-scheme: dark) {
  .pipeline-stage .count-box.published { background: rgba(69,123,157,0.2); }
  .pipeline-stage .count-box.handling { background: rgba(233,196,106,0.15); }
  .pipeline-stage .count-box.done { background: rgba(42,157,143,0.15); }
  .pipeline-stage .count-box.failed { background: rgba(231,111,81,0.15); }
}

/* Throughput chart */
.sparkline-container {
  padding: 12px 16px;
}

.sparkline-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 8px;
}

.sparkline-header .chart-title {
  font-size: 13px;
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.sparkline-stats {
  display: flex;
  gap: 24px;
  margin-top: 8px;
  font-size: 13px;
}

.sparkline-stats .stat-label { color: var(--text-muted); }
.sparkline-stats .stat-value { font-family: var(--font-code); font-weight: 500; }

.time-labels {
  display: flex;
  justify-content: space-between;
  font-size: 10px;
  color: var(--text-muted);
  font-family: var(--font-code);
  padding: 2px 0 0;
}

/* Feed controls */
.feed-controls {
  display: flex;
  gap: 8px;
  align-items: center;
}

.feed-controls select, .feed-controls input {
  padding: 3px 8px;
  border: 1px solid var(--border);
  border-radius: 4px;
  font-family: var(--font-text);
  font-size: 12px;
  background: var(--surface);
  color: var(--text);
}

.feed-controls input { width: 180px; }

.feed-tab {
  background: none;
  border: none;
  padding: 3px 10px;
  font-family: var(--font-text);
  font-size: 12px;
  color: var(--text-muted);
  cursor: pointer;
  border-bottom: 2px solid transparent;
  transition: all 0.15s;
}

.feed-tab:hover { color: var(--text); }
.feed-tab.active {
  color: var(--text);
  border-bottom-color: var(--secondary);
  font-weight: 600;
}

.feed-tab .error-badge {
  background: var(--accent);
  color: white;
  font-size: 10px;
  padding: 1px 5px;
  border-radius: 8px;
  margin-left: 4px;
  font-weight: 600;
}

/* Content area for both tabs */
.tab-content {
  max-height: 600px;
  overflow-y: auto;
  scroll-behavior: smooth;
}

.feed-empty {
  padding: 40px;
  text-align: center;
  color: var(--text-muted);
  font-size: 14px;
}

.feed-divider {
  padding: 6px 16px;
  font-size: 11px;
  color: var(--text-muted);
  text-align: center;
  border-bottom: 1px solid var(--border);
  background: var(--bg);
  font-family: var(--font-code);
  letter-spacing: 0.05em;
}

/* --- Messages Tab --- */
.msg-row {
  border-bottom: 1px solid var(--border);
  cursor: pointer;
  transition: background 0.15s;
}

.msg-row:hover { background: var(--bg); }
.msg-row.new { animation: fadeIn 0.3s ease-out; }

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(-4px); }
  to { opacity: 1; transform: translateY(0); }
}

.msg-summary {
  display: grid;
  grid-template-columns: 90px 1fr auto;
  align-items: center;
  gap: 12px;
  padding: 10px 16px;
}

.msg-summary .msg-time {
  font-family: var(--font-code);
  font-size: 12px;
  color: var(--text-muted);
  white-space: nowrap;
}

.msg-summary .msg-info {
  display: flex;
  flex-direction: column;
  gap: 4px;
  min-width: 0;
}

.msg-summary .msg-type {
  font-weight: 600;
  font-size: 13px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.msg-summary .msg-stream {
  font-family: var(--font-code);
  font-size: 11px;
  color: var(--text-muted);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.msg-summary .msg-id {
  font-family: var(--font-code);
  font-size: 10px;
  color: var(--text-muted);
  opacity: 0.7;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

/* Horizontal lifecycle bar */
.lifecycle-bar {
  display: flex;
  align-items: center;
  gap: 0;
  padding: 2px 16px 10px;
}

.lbar-stage {
  display: flex;
  align-items: center;
  gap: 0;
}

.lbar-marker {
  width: 14px;
  height: 14px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 9px;
  font-weight: 700;
  color: white;
  flex-shrink: 0;
  position: relative;
}

.lbar-marker.published { background: var(--secondary); }
.lbar-marker.started { background: var(--warning); color: #333; }
.lbar-marker.completed { background: var(--success); }
.lbar-marker.acked { background: var(--success); }
.lbar-marker.failed { background: var(--accent); }
.lbar-marker.nacked { background: var(--warning); color: #333; }
.lbar-marker.dlq { background: var(--accent); }

.lbar-line {
  width: 24px;
  height: 2px;
  flex-shrink: 0;
}

.lbar-line.ok { background: var(--success); }
.lbar-line.pending { background: var(--border); }
.lbar-line.error { background: var(--accent); }
.lbar-line.warn { background: var(--warning); }

.lbar-label {
  font-family: var(--font-code);
  font-size: 10px;
  color: var(--text-muted);
  margin-left: 4px;
  white-space: nowrap;
}

.lbar-in-progress {
  font-family: var(--font-code);
  font-size: 10px;
  color: var(--text-muted);
  margin-left: 4px;
  animation: blink 1.2s infinite;
}

@keyframes blink {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.3; }
}

/* Expanded message detail */
.msg-detail {
  display: none;
  border-top: 1px solid var(--border);
  background: var(--bg);
  padding: 16px;
}

.msg-row.expanded .msg-detail { display: block; }
.msg-row.expanded { background: var(--bg); }

.detail-columns {
  display: flex;
  gap: 20px;
  align-items: flex-start;
}

.detail-col-left {
  flex: 1;
  min-width: 0;
}

.detail-col-right {
  width: 340px;
  flex-shrink: 0;
}

@media (max-width: 900px) {
  .detail-columns { flex-direction: column; }
  .detail-col-right { width: 100%; }
}

.detail-section {
  margin-bottom: 16px;
}

.detail-section:last-child { margin-bottom: 0; }

.detail-section-title {
  font-size: 11px;
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  margin-bottom: 8px;
  display: flex;
  align-items: center;
  justify-content: space-between;
}

/* Detailed horizontal timeline */
.detail-timeline {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.detail-timeline-row {
  display: flex;
  align-items: center;
  gap: 0;
}

.dtl-stage {
  display: flex;
  align-items: center;
  flex-direction: column;
  min-width: 70px;
  text-align: center;
}

.dtl-marker {
  width: 18px;
  height: 18px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 10px;
  font-weight: 700;
  color: white;
}

.dtl-marker.published { background: var(--secondary); }
.dtl-marker.started { background: var(--warning); color: #333; }
.dtl-marker.completed { background: var(--success); }
.dtl-marker.acked { background: var(--success); }
.dtl-marker.failed { background: var(--accent); }
.dtl-marker.nacked { background: var(--warning); color: #333; }
.dtl-marker.dlq { background: var(--accent); }

.dtl-event-name {
  font-family: var(--font-code);
  font-size: 10px;
  color: var(--text);
  margin-top: 2px;
  font-weight: 500;
}

.dtl-time {
  font-family: var(--font-code);
  font-size: 10px;
  color: var(--text-muted);
}

.dtl-handler {
  font-size: 11px;
  color: var(--text-muted);
}

.dtl-line {
  flex: 1;
  height: 2px;
  min-width: 20px;
  margin: 0 4px;
  margin-bottom: 26px;
}

.dtl-line.ok { background: var(--success); }
.dtl-line.error { background: var(--accent); }
.dtl-line.pending { background: var(--border); }

.dtl-duration {
  font-family: var(--font-code);
  font-size: 10px;
  color: var(--text-muted);
  margin-bottom: 26px;
  margin-left: 4px;
  margin-right: 4px;
  white-space: nowrap;
}

/* Multi-handler expanded timeline */
.dtl-published-row {
  display: flex;
  align-items: center;
  gap: 0;
  padding: 4px 0;
}

.dtl-handler-group {
  padding: 6px 0 4px;
  border-top: 1px solid var(--border);
}

.dtl-handler-group:first-of-type {
  border-top: none;
}

.dtl-handler-label {
  font-family: var(--font-code);
  font-size: 11px;
  font-weight: 600;
  color: var(--text);
  margin-bottom: 4px;
  padding-left: 2px;
}

.dtl-handler-stages {
  display: flex;
  align-items: center;
  gap: 0;
  padding-left: 8px;
}

/* Summary bar handler segments */
.lbar-handler-segment {
  display: flex;
  align-items: center;
  gap: 0;
}

.lbar-handler-name {
  font-family: var(--font-code);
  font-size: 9px;
  color: var(--text-muted);
  margin-right: 4px;
  max-width: 120px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

/* New messages banner */
.new-messages-banner {
  position: sticky;
  top: 0;
  z-index: 10;
  background: var(--secondary);
  color: white;
  text-align: center;
  padding: 6px 16px;
  font-size: 13px;
  font-weight: 600;
  cursor: pointer;
  border-radius: 0 0 8px 8px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.2);
  transition: opacity 0.2s;
}

.new-messages-banner:hover {
  opacity: 0.9;
}

/* Payload viewer */
.payload-container {
  position: relative;
}

.payload-block {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 12px;
  font-family: var(--font-code);
  font-size: 12px;
  line-height: 1.6;
  white-space: pre-wrap;
  word-break: break-all;
  max-height: 300px;
  overflow-y: auto;
  color: var(--text);
}

.copy-btn {
  background: var(--bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 3px 10px;
  font-family: var(--font-code);
  font-size: 11px;
  color: var(--text-muted);
  cursor: pointer;
  transition: all 0.15s;
}

.copy-btn:hover { border-color: var(--secondary); color: var(--text); }
.copy-btn.copied { background: var(--success); color: white; border-color: var(--success); }

.payload-empty {
  font-size: 12px;
  color: var(--text-muted);
  font-style: italic;
}

/* Error detail */
.error-detail-box {
  background: #FFF5F5;
  border: 1px solid var(--accent);
  border-radius: 6px;
  padding: 10px 12px;
  font-family: var(--font-code);
  font-size: 12px;
  color: var(--accent);
  line-height: 1.5;
}

@media (prefers-color-scheme: dark) {
  .error-detail-box { background: rgba(231,111,81,0.1); }
}

/* Events tab - reuses old feed styles */
.feed-item {
  padding: 8px 16px;
  border-bottom: 1px solid var(--border);
  border-left: 3px solid transparent;
  transition: background 0.15s;
  cursor: pointer;
  display: grid;
  grid-template-columns: 90px 20px 140px 1fr auto;
  align-items: start;
  gap: 8px;
  font-size: 13px;
}

.feed-item:hover { background: var(--bg); }
.feed-item.selected { background: var(--bg); }
.feed-item.status-ok { border-left-color: var(--success); }
.feed-item.status-error { border-left-color: var(--accent); }
.feed-item.status-retry { border-left-color: var(--warning); }
.feed-item.new { animation: fadeIn 0.3s ease-out; }

.feed-item .timestamp {
  font-family: var(--font-code);
  font-size: 12px;
  color: var(--text-muted);
  white-space: nowrap;
}

.feed-item .icon { font-size: 14px; }
.feed-item .event-type {
  font-family: var(--font-code);
  font-size: 12px;
  font-weight: 500;
}

.feed-item .message-info {
  display: flex;
  flex-direction: column;
  gap: 2px;
  min-width: 0;
}

.feed-item .message-type {
  font-weight: 600;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.feed-item .message-detail {
  font-size: 12px;
  color: var(--text-muted);
  font-family: var(--font-code);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.feed-item .duration {
  font-family: var(--font-code);
  font-size: 12px;
  color: var(--text-muted);
  white-space: nowrap;
}

.feed-item .error-text {
  color: var(--accent);
  font-size: 12px;
}

/* Infrastructure */
.infra-grid {
  display: flex;
  flex-wrap: wrap;
  gap: 16px;
  font-size: 13px;
}

.infra-item {
  display: flex;
  align-items: center;
  gap: 6px;
}

.infra-item .label { color: var(--text-muted); }
.infra-item .value { font-family: var(--font-code); font-weight: 500; }

/* Backpressure Section */
.backpressure-grid {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
  gap: 16px;
  padding: 16px;
}

@media (max-width: 900px) {
  .backpressure-grid { grid-template-columns: 1fr; }
}

.bp-gauge {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 6px;
  padding: 12px;
  border-radius: 8px;
  background: var(--bg);
  border: 1px solid var(--border);
  transition: border-color 0.3s;
}

.bp-gauge.warn { border-color: var(--warning); }
.bp-gauge.critical { border-color: var(--accent); }

.bp-gauge .bp-label {
  font-size: 11px;
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.bp-gauge .bp-value {
  font-family: var(--font-code);
  font-size: 28px;
  font-weight: 500;
  transition: color 0.3s;
}

.bp-gauge .bp-value.ok { color: var(--success); }
.bp-gauge .bp-value.warn { color: #E65100; }
.bp-gauge .bp-value.critical { color: var(--accent); }

.bp-gauge .bp-subtitle {
  font-size: 11px;
  color: var(--text-muted);
  font-family: var(--font-code);
}

/* Queue depth chart */
.queue-chart-container {
  padding: 12px 16px;
}

.queue-chart-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 8px;
}

.queue-chart-header .chart-title {
  font-size: 13px;
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.queue-legend {
  display: flex;
  gap: 16px;
  font-size: 12px;
}

.queue-legend-item {
  display: flex;
  align-items: center;
  gap: 4px;
}

.queue-legend-swatch {
  width: 12px;
  height: 3px;
  border-radius: 2px;
}

/* Consumer lag table */
.lag-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 13px;
}

.lag-table th {
  font-size: 11px;
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  text-align: left;
  padding: 8px 12px;
  border-bottom: 1px solid var(--border);
}

.lag-table td {
  padding: 6px 12px;
  border-bottom: 1px solid var(--border);
  font-family: var(--font-code);
  font-size: 12px;
}

.lag-table tr:last-child td { border-bottom: none; }

.lag-bar-bg {
  background: var(--bg);
  border-radius: 3px;
  height: 6px;
  width: 100%;
  overflow: hidden;
}

.lag-bar-fill {
  height: 100%;
  border-radius: 3px;
  transition: width 0.5s ease, background 0.3s;
}

.lag-bar-fill.ok { background: var(--success); }
.lag-bar-fill.warn { background: var(--warning); }
.lag-bar-fill.critical { background: var(--accent); }

/* New events badge */
.new-events-badge {
  display: none;
  position: fixed;
  bottom: 24px;
  left: 50%;
  transform: translateX(-50%);
  background: var(--primary);
  color: white;
  padding: 8px 16px;
  border-radius: 20px;
  font-size: 13px;
  cursor: pointer;
  z-index: 100;
  box-shadow: 0 2px 8px rgba(0,0,0,0.2);
}
</style>
</head>
<body>

<!-- Header -->
<div class="header">
  <div class="header-left">
    <span class="logo">&#9670; Protean Observatory</span>
    <span class="subtitle">Real-time message flow</span>
  </div>
  <div class="header-right">
    <span class="status-dot disconnected" id="statusDot"></span>
    <select id="filterDomain">
      <option value="">All domains</option>
    </select>
    <button class="btn" id="pauseBtn" onclick="togglePause()">&#9208; Pause</button>
    <button class="btn" id="resetBtn" onclick="resetDashboard()">&#8634; Reset</button>
  </div>
</div>

<!-- Main -->
<div class="main">

  <!-- Summary Metrics Bar -->
  <div class="card">
    <div class="summary-bar">
      <div class="summary-metrics">
        <div class="summary-metric" title="Total trace events per minute in the selected time window. Includes all event types (published, handler completions, failures).">
          <span class="metric-label">Throughput</span>
          <span class="metric-value good" id="metricThroughput">--</span>
        </div>
        <div class="summary-metric" title="Percentage of events that are errors (handler failures, DLQ) out of all events in the selected window.">
          <span class="metric-label">Error Rate</span>
          <span class="metric-value good" id="metricErrorRate">--</span>
        </div>
        <div class="summary-metric" title="Average time handlers take to process a message, measured from handler.started to handler.completed.">
          <span class="metric-label">Avg Latency</span>
          <span class="metric-value good" id="metricLatency">--</span>
        </div>
        <div class="summary-metric" title="Messages that have been published but not yet fully processed by all their handlers. Based on trace events — may include stale entries if engines were restarted.">
          <span class="metric-label">In Flight</span>
          <span class="metric-value good" id="metricInFlight">0</span>
        </div>
      </div>
      <div class="window-selector" title="Time window for summary metrics and pipeline counts. Controls how far back trace events are aggregated.">
        <button class="window-btn active" data-window="5m" onclick="setWindow('5m')">5m</button>
        <button class="window-btn" data-window="15m" onclick="setWindow('15m')">15m</button>
        <button class="window-btn" data-window="1h" onclick="setWindow('1h')">1h</button>
        <button class="window-btn" data-window="24h" onclick="setWindow('24h')">24h</button>
        <button class="window-btn" data-window="7d" onclick="setWindow('7d')">7d</button>
      </div>
    </div>
  </div>

  <!-- Pipeline -->
  <div class="card">
    <div class="pipeline">
      <div class="pipeline-stage" title="Count of outbox.published trace events — messages that the OutboxProcessor has successfully pushed from the database outbox to Redis Streams.">
        <span class="label">Published</span>
        <div class="count-box published" id="pipePublished">0</div>
        <span class="rate-label" id="ratePublishedPipe">&nbsp;</span>
      </div>
      <span class="pipeline-arrow">&#9654;</span>
      <div class="pipeline-stage" title="Messages currently being processed by event handlers (handler.started minus handler.completed/failed). Shows 0 when no handlers are actively running.">
        <span class="label">Handling</span>
        <div class="count-box handling" id="pipeHandling">0</div>
        <span class="rate-label" id="rateHandling">&nbsp;</span>
      </div>
      <span class="pipeline-arrow">&#9654;</span>
      <div class="pipeline-stage" title="Count of handler.completed trace events — successful handler executions. Higher than Published when each message is processed by multiple handlers (projectors).">
        <span class="label">Done</span>
        <div class="count-box done" id="pipeDone">0</div>
        <span class="rate-label" id="rateDone">&nbsp;</span>
      </div>
      <span class="pipeline-arrow">&#9654;</span>
      <div class="pipeline-stage" title="Count of handler failures, outbox publish failures, and messages sent to the dead-letter queue.">
        <span class="label">Failed</span>
        <div class="count-box failed" id="pipeFailed">0</div>
        <span class="rate-label" id="rateFailed">&nbsp;</span>
      </div>
    </div>
  </div>

  <!-- Backpressure -->
  <div class="card" id="backpressureCard">
    <div class="card-header">
      <span>Backpressure</span>
      <span style="font-size:11px;color:var(--text-muted);font-family:var(--font-code)" id="bpLastUpdated"></span>
    </div>
    <div class="backpressure-grid">
      <div class="bp-gauge" id="bpOutbox" title="Messages in the PostgreSQL outbox table with PENDING or PROCESSING status, waiting for the OutboxProcessor (engine) to publish them to Redis. If this stays high, the engine may not be running or is falling behind.">
        <span class="bp-label">Outbox Pending</span>
        <span class="bp-value ok" id="bpOutboxValue">0</span>
        <span class="bp-subtitle" id="bpOutboxDetail">waiting to publish</span>
      </div>
      <div class="bp-gauge" id="bpStream" title="Total messages sitting in Redis Streams (XLEN) across all streams. These have been published but not yet read by consumer groups. Grows when the outbox publishes faster than handlers can consume.">
        <span class="bp-label">Stream Depth</span>
        <span class="bp-value ok" id="bpStreamValue">0</span>
        <span class="bp-subtitle" id="bpStreamDetail">in Redis Streams</span>
      </div>
      <div class="bp-gauge" id="bpConsumer" title="Messages delivered to consumer groups but not yet acknowledged (XPENDING). These are actively being processed or waiting for retry. High values indicate slow handlers or a downstream bottleneck.">
        <span class="bp-label">Consumer Lag</span>
        <span class="bp-value ok" id="bpConsumerValue">0</span>
        <span class="bp-subtitle" id="bpConsumerDetail">unacknowledged</span>
      </div>
    </div>
  </div>

  <!-- Queue Depth Chart -->
  <div class="card" id="queueDepthCard">
    <div class="queue-chart-container">
      <div class="queue-chart-header">
        <span class="chart-title" title="Time-series view of queue depth at each stage. During a burst or migration, you'll see a mountain shape — steep rise as events accumulate, gradual decline as handlers drain the backlog.">Queue Depth (5 min)</span>
        <div class="queue-legend">
          <div class="queue-legend-item" title="Messages waiting in the PostgreSQL outbox (PENDING + PROCESSING).">
            <div class="queue-legend-swatch" style="background:#E76F51"></div>
            <span>Outbox</span>
          </div>
          <div class="queue-legend-item" title="Messages sitting in Redis Streams waiting to be consumed (XLEN).">
            <div class="queue-legend-swatch" style="background:#457B9D"></div>
            <span>Stream</span>
          </div>
          <div class="queue-legend-item" title="Messages delivered to consumers but not yet acknowledged (XPENDING).">
            <div class="queue-legend-swatch" style="background:#E9C46A"></div>
            <span>Consumer Lag</span>
          </div>
        </div>
      </div>
      <canvas id="queueSparkline" width="1000" height="80"></canvas>
      <div class="time-labels">
        <span>5m ago</span>
        <span>4m</span>
        <span>3m</span>
        <span>2m</span>
        <span>1m</span>
        <span>now</span>
      </div>
    </div>
  </div>

  <!-- Consumer Lag Detail -->
  <div class="card" id="consumerLagCard">
    <div class="card-header">
      <span title="Per-stream, per-consumer-group breakdown of queue depth. Shows exactly which handler is the bottleneck.">Consumer Lag by Stream</span>
    </div>
    <div class="card-body" id="consumerLagBody">
      <table class="lag-table" id="lagTable">
        <thead>
          <tr>
            <th title="Redis Stream name in the format domain::aggregate.">Stream</th>
            <th title="Total messages in this Redis Stream (XLEN). Includes both consumed and unconsumed messages.">Length</th>
            <th title="Handler subscribed to this stream via a consumer group. Each handler gets its own independent read position.">Consumer Group</th>
            <th title="Messages delivered to this consumer group but not yet acknowledged (XPENDING). High values indicate a slow handler.">Pending</th>
            <th style="width:120px" title="Visual representation of pending count relative to the largest stream length.">Lag</th>
          </tr>
        </thead>
        <tbody id="lagTableBody">
          <tr><td colspan="5" style="text-align:center;color:var(--text-muted)">Loading...</td></tr>
        </tbody>
      </table>
    </div>
  </div>

  <!-- Throughput Chart -->
  <div class="card">
    <div class="sparkline-container">
      <div class="sparkline-header">
        <span class="chart-title" title="Real-time event throughput over the last 5 minutes. The blue bars show outbox publishing rate, the green line shows handler completion rate, and red dots mark errors.">Throughput (5 min)</span>
        <div class="sparkline-stats">
          <div title="Events published from outbox to Redis per second (outbox.published events)."><span class="stat-label">Published:</span> <span class="stat-value" id="ratePublished">0/s</span></div>
          <div title="Handler completions per second (handler.completed events)."><span class="stat-label">Processed:</span> <span class="stat-value" id="rateProcessed">0/s</span></div>
          <div title="Handler failures and DLQ events per second."><span class="stat-label">Errors:</span> <span class="stat-value" id="rateErrors">0/s</span></div>
        </div>
      </div>
      <canvas id="sparkline" width="1000" height="80"></canvas>
      <div class="time-labels">
        <span>5m ago</span>
        <span>4m</span>
        <span>3m</span>
        <span>2m</span>
        <span>1m</span>
        <span>now</span>
      </div>
    </div>
  </div>

  <!-- Messages / Events -->
  <div class="card">
    <div class="card-header">
      <div style="display:flex; align-items:center; gap:8px;">
        <button class="feed-tab active" id="tabMessages" onclick="setViewTab('messages')" title="Messages grouped by message ID, showing the full lifecycle of each event across all handlers.">Messages</button>
        <button class="feed-tab" id="tabEvents" onclick="setViewTab('events')" title="Chronological stream of individual trace events (published, started, completed, failed, acked).">Events</button>
        <button class="feed-tab" id="tabErrors" onclick="setViewTab('errors')" title="Messages that have at least one error event (handler failure, DLQ, nack).">Errors <span class="error-badge" id="errorBadge" style="display:none">0</span></button>
      </div>
      <div class="feed-controls">
        <select id="filterStream">
          <option value="">All streams</option>
        </select>
        <input type="text" id="filterSearch" placeholder="Search type, handler, or message ID..." oninput="applyFilters()">
      </div>
    </div>
    <!-- Messages tab content -->
    <div class="tab-content" id="messagesContent">
      <div class="new-messages-banner" id="newMessagesBanner" onclick="scrollToTopMessages()" style="display:none">
        &uarr; <span id="newMsgCount">0</span> new messages
      </div>
      <div class="feed-empty" id="messagesEmpty">Loading history...</div>
    </div>
    <!-- Events tab content (hidden by default) -->
    <div class="tab-content" id="eventsContent" style="display:none">
      <div class="feed-empty" id="eventsEmpty">Loading history...</div>
    </div>
  </div>

  <!-- Infrastructure -->
  <div class="card">
    <div class="card-header">Infrastructure</div>
    <div class="card-body">
      <div class="infra-grid" id="infraGrid">
        <div class="infra-item">
          <span class="status-dot disconnected" id="redisStatus"></span>
          <span class="label">Redis</span>
          <span class="value" id="redisInfo">Checking...</span>
        </div>
      </div>
    </div>
  </div>

</div>

<div class="new-events-badge" id="newEventsBadge" onclick="scrollToTop()">
  &#8595; New events
</div>

<script>
// --- State ---
let paused = false;
let connected = false;
let eventSource = null;
let pauseBuffer = [];
const MAX_ITEMS = 500;

// Current window for stats
let currentWindow = '5m';

// Current view tab: 'messages', 'events', 'errors'
let currentTab = 'messages';

// History / dedup
let historyLoaded = false;
const seenTraceKeys = new Set();
let sseConnectedAt = 0;

// All traces in memory for lifecycle lookup
const tracesByMessageId = new Map(); // message_id -> [{...}, ...]
let errorCount = 0;

// Message-centric data
const messageById = new Map();   // message_id -> { message_id, message_type, stream, domain, first_ts, stages: [], payload: null, hasError: false }
const messageOrder = [];         // message_ids in newest-first order

// Currently expanded message
let expandedMessageId = null;

// Batched rendering state
let pendingMessageUpdates = new Set();  // message_ids needing DOM update
let pendingEventItems = [];             // event data items to add to events tab
let rafScheduled = false;

// Scroll-aware state for messages tab
let userScrolledMessages = false;
let newMessageCount = 0;

// Real-time metrics state (SSE delta + server poll base)
let statsBase = null;           // Last /api/traces/stats response
let statsDelta = {};            // event_type -> count (SSE increments since last poll)
let latencyDeltaSum = 0;        // Sum of handler.completed duration_ms since last poll
let latencyDeltaCount = 0;      // Count of handler.completed events since last poll
let metricsRafScheduled = false;

const ERROR_EVENTS = new Set(['handler.failed', 'outbox.failed', 'message.dlq', 'message.nacked']);

// Known domains and streams for filter population
const knownDomains = new Set();
const knownStreams = new Set();

// Throughput tracking (per-second buckets for last 300s = 5 min)
const THROUGHPUT_SECONDS = 300;
const throughput = {
  published: new Array(THROUGHPUT_SECONDS).fill(0),
  processed: new Array(THROUGHPUT_SECONDS).fill(0),
  errors: new Array(THROUGHPUT_SECONDS).fill(0),
};
let currentSecond = { published: 0, processed: 0, errors: 0 };

// Queue depth tracking (per-second buckets for last 300s = 5 min, like throughput)
const QUEUE_DEPTH_SECONDS = 300;
const queueDepth = {
  outbox: new Array(QUEUE_DEPTH_SECONDS).fill(0),
  stream: new Array(QUEUE_DEPTH_SECONDS).fill(0),
  consumer: new Array(QUEUE_DEPTH_SECONDS).fill(0),
};
let latestQueueDepth = { outbox: 0, stream: 0, consumer: 0 };
let queueDepthDetail = { outbox: {}, streams: {} };

// Event icons for events tab
const EVENT_ICONS = {
  'outbox.published': '\u2191',
  'outbox.failed': '\u2717',
  'handler.started': '\u25b6',
  'handler.completed': '\u2713',
  'handler.failed': '\u2717',
  'message.acked': '\u2713',
  'message.nacked': '\u21bb',
  'message.dlq': '\u26a0',
};

const EVENT_STATUS_CLASS = {
  'outbox.published': 'status-ok',
  'outbox.failed': 'status-error',
  'handler.started': 'status-ok',
  'handler.completed': 'status-ok',
  'handler.failed': 'status-error',
  'message.acked': 'status-ok',
  'message.nacked': 'status-retry',
  'message.dlq': 'status-error',
};

// Stage ordering for lifecycle bar
const STAGE_ORDER = {
  'outbox.published': 0,
  'handler.started': 1,
  'handler.completed': 2,
  'handler.failed': 2,
  'message.acked': 3,
  'message.nacked': 3,
  'message.dlq': 3,
  'outbox.failed': 1,
};

// Marker CSS class for each event type
const MARKER_CLASS = {
  'outbox.published': 'published',
  'handler.started': 'started',
  'handler.completed': 'completed',
  'handler.failed': 'failed',
  'message.acked': 'acked',
  'message.nacked': 'nacked',
  'message.dlq': 'dlq',
  'outbox.failed': 'failed',
};

// Short labels for lifecycle bar markers
const MARKER_ICON = {
  'outbox.published': '\u2191',
  'handler.started': '\u25b6',
  'handler.completed': '\u2713',
  'handler.failed': '\u2717',
  'message.acked': '\u2713',
  'message.nacked': '\u21bb',
  'message.dlq': '!',
  'outbox.failed': '\u2717',
};

// --- History Loading ---
async function loadHistory() {
  try {
    const res = await fetch('/api/traces?count=500');
    if (!res.ok) return;
    const data = await res.json();
    const traces = data.traces || [];

    if (traces.length === 0) {
      setEmptyMessage('No events in history. Connect engines to see message flow.');
      return;
    }

    // Remove empty messages
    clearEmptyMessages();

    // Process oldest-first for correct grouping
    const reversed = [...traces].reverse();
    for (const trace of reversed) {
      const key = trace.message_id + ':' + trace.event + ':' + (trace.handler || '');
      seenTraceKeys.add(key);
      trackTrace(trace);
      updateThroughputFromHistory(trace);
    }

    renderAllMessages();

    // Insert divider in events tab
    const eventsDiv = document.getElementById('eventsContent');
    const divider = document.createElement('div');
    divider.className = 'feed-divider';
    divider.id = 'historyDivider';
    divider.textContent = '--- live ---';
    eventsDiv.insertBefore(divider, eventsDiv.firstChild);

    // Render events tab
    const allTraces = [...traces]; // newest-first from API
    for (const trace of allTraces) {
      addEventFeedItem(trace, true);
    }

    historyLoaded = true;
    updateErrorBadge();
  } catch (e) {
    console.error('Failed to load history:', e);
    setEmptyMessage('Failed to load history. Waiting for live events...');
  }
}

function setEmptyMessage(msg) {
  const mEmpty = document.getElementById('messagesEmpty');
  if (mEmpty) mEmpty.textContent = msg;
  const eEmpty = document.getElementById('eventsEmpty');
  if (eEmpty) eEmpty.textContent = msg;
}

function clearEmptyMessages() {
  const mEmpty = document.getElementById('messagesEmpty');
  if (mEmpty) mEmpty.remove();
  const eEmpty = document.getElementById('eventsEmpty');
  if (eEmpty) eEmpty.remove();
}

function updateThroughputFromHistory(trace) {
  const ts = trace.timestamp ? new Date(trace.timestamp).getTime() : 0;
  if (!ts) return;

  const now = Date.now();
  const ageSeconds = Math.floor((now - ts) / 1000);
  const bucketIndex = THROUGHPUT_SECONDS - 1 - ageSeconds;
  if (bucketIndex < 0 || bucketIndex >= THROUGHPUT_SECONDS) return;

  if (trace.event === 'outbox.published') throughput.published[bucketIndex]++;
  if (trace.event === 'handler.completed') throughput.processed[bucketIndex]++;
  if (trace.event === 'handler.failed' || trace.event === 'message.dlq') throughput.errors[bucketIndex]++;
}

// --- In-Flight Computation ---
function computeInFlight() {
  let count = 0;
  for (const [id, msg] of messageById) {
    const stages = msg.stages;
    const isPublished = stages.some(s => s.event === 'outbox.published');
    if (!isPublished) continue;

    const startedHandlers = new Set();
    const doneHandlers = new Set();
    for (const s of stages) {
      if (s.event === 'handler.started') startedHandlers.add(s.handler);
      if (s.event === 'handler.completed' || s.event === 'handler.failed')
        doneHandlers.add(s.handler);
    }

    // In flight if: published and (no handlers started OR some started but not done)
    if (startedHandlers.size === 0 || startedHandlers.size > doneHandlers.size) {
      count++;
    }
  }
  return count;
}

// --- Stats Loading ---
async function loadStats() {
  try {
    const res = await fetch('/api/traces/stats?window=' + currentWindow);
    if (!res.ok) return;
    const data = await res.json();

    // Store server response as base, reset SSE deltas
    statsBase = data;
    statsDelta = {};
    latencyDeltaSum = 0;
    latencyDeltaCount = 0;

    refreshMetrics();
  } catch (e) {
    console.error('Failed to load stats:', e);
  }
}

// --- Unified Metrics Refresh (base + SSE deltas) ---
function refreshMetrics() {
  if (!statsBase) return;

  // Merge base counts with SSE delta increments
  const counts = { ...(statsBase.counts || {}) };
  for (const [evt, n] of Object.entries(statsDelta)) {
    counts[evt] = (counts[evt] || 0) + n;
  }

  const total = Object.values(counts).reduce((a, b) => a + b, 0);
  const windowMinutes = { '5m': 5, '15m': 15, '1h': 60, '24h': 1440, '7d': 10080 }[currentWindow] || 5;

  // Throughput
  const perMin = total > 0 ? Math.round(total / windowMinutes) : 0;
  document.getElementById('metricThroughput').textContent = perMin + '/min';

  // Error rate
  const errCount = (counts['handler.failed'] || 0) + (counts['outbox.failed'] || 0) + (counts['message.dlq'] || 0);
  const errorRate = total > 0 ? Math.round(errCount / total * 10000) / 100 : 0;
  const errorEl = document.getElementById('metricErrorRate');
  errorEl.textContent = errorRate + '%';
  errorEl.className = 'metric-value ' + (errorRate === 0 ? 'good' : errorRate < 5 ? 'warn' : 'bad');

  // Avg latency (blend base + SSE delta)
  const baseCompleted = (statsBase.counts || {})['handler.completed'] || 0;
  const baseLatencySum = (statsBase.avg_latency_ms || 0) * baseCompleted;
  const totalLatencySum = baseLatencySum + latencyDeltaSum;
  const totalLatencyCount = baseCompleted + latencyDeltaCount;
  const avgLatency = totalLatencyCount > 0 ? Math.round(totalLatencySum / totalLatencyCount * 100) / 100 : 0;
  const latencyEl = document.getElementById('metricLatency');
  latencyEl.textContent = avgLatency > 0 ? avgLatency + 'ms' : '--';

  // In Flight
  const inFlight = computeInFlight();
  const inFlightEl = document.getElementById('metricInFlight');
  inFlightEl.textContent = inFlight;
  inFlightEl.className = 'metric-value ' + (inFlight === 0 ? 'good' : inFlight <= 10 ? 'warn' : 'bad');
}

// Pipeline counts — updated on 1-second tick (not on every SSE event) to avoid jitter
function refreshPipeline() {
  if (!statsBase) return;

  const counts = { ...(statsBase.counts || {}) };
  for (const [evt, n] of Object.entries(statsDelta)) {
    counts[evt] = (counts[evt] || 0) + n;
  }

  const windowMinutes = { '5m': 5, '15m': 15, '1h': 60, '24h': 1440, '7d': 10080 }[currentWindow] || 5;
  const errCount = (counts['handler.failed'] || 0) + (counts['outbox.failed'] || 0) + (counts['message.dlq'] || 0);

  const published = counts['outbox.published'] || 0;
  const handling = Math.max(0, (counts['handler.started'] || 0) - (counts['handler.completed'] || 0) - (counts['handler.failed'] || 0));
  const done = counts['handler.completed'] || 0;
  const failed = errCount;

  document.getElementById('pipePublished').textContent = published;
  document.getElementById('pipeHandling').textContent = handling;
  document.getElementById('pipeDone').textContent = done;
  document.getElementById('pipeFailed').textContent = failed;

  document.getElementById('ratePublishedPipe').textContent = published > 0 ? '~' + Math.round(published / windowMinutes) + '/min' : '';
  document.getElementById('rateHandling').textContent = handling > 0 ? '~' + Math.round(handling / windowMinutes) + '/min' : '';
  document.getElementById('rateDone').textContent = done > 0 ? '~' + Math.round(done / windowMinutes) + '/min' : '';
  document.getElementById('rateFailed').textContent = failed > 0 ? '~' + Math.round(failed / windowMinutes) + '/min' : '';
}

function scheduleMetricsRefresh() {
  if (!metricsRafScheduled) {
    metricsRafScheduled = true;
    requestAnimationFrame(() => {
      metricsRafScheduled = false;
      refreshMetrics();
    });
  }
}

function setWindow(w) {
  currentWindow = w;
  document.querySelectorAll('.window-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.window === w);
  });
  loadStats();
}

// --- Trace Tracking ---
function trackTrace(data) {
  if (!data.message_id) return;

  // Track in tracesByMessageId
  if (!tracesByMessageId.has(data.message_id)) {
    tracesByMessageId.set(data.message_id, []);
  }
  tracesByMessageId.get(data.message_id).push(data);

  if (ERROR_EVENTS.has(data.event)) {
    errorCount++;
  }

  // Track in message-centric data
  if (!messageById.has(data.message_id)) {
    const entry = {
      message_id: data.message_id,
      message_type: data.message_type || 'Unknown',
      stream: data.stream || '',
      domain: data.domain || '',
      first_ts: data.timestamp || new Date().toISOString(),
      stages: [],
      payload: null,
      hasError: false,
    };
    messageById.set(data.message_id, entry);
    messageOrder.unshift(data.message_id);
  }

  const msg = messageById.get(data.message_id);
  msg.stages.push(data);

  if (data.payload) {
    msg.payload = data.payload;
  }
  if (ERROR_EVENTS.has(data.event)) {
    msg.hasError = true;
  }

  // Track domains and streams for filters
  if (data.domain && !knownDomains.has(data.domain)) {
    knownDomains.add(data.domain);
    updateDomainFilter();
  }
  if (data.stream && !knownStreams.has(data.stream)) {
    knownStreams.add(data.stream);
    updateStreamFilter();
  }
}

// --- SSE Connection ---
function connectSSE() {
  const params = new URLSearchParams();
  const domainFilter = document.getElementById('filterDomain').value;
  if (domainFilter) params.set('domain', domainFilter);

  const url = '/stream' + (params.toString() ? '?' + params.toString() : '');
  eventSource = new EventSource(url);

  eventSource.addEventListener('trace', (e) => {
    try {
      const data = JSON.parse(e.data);
      handleTraceEvent(data);
    } catch (err) {
      console.error('Parse error:', err);
    }
  });

  eventSource.addEventListener('error', (e) => {
    try {
      const data = JSON.parse(e.data);
      console.error('Observatory error:', data.error);
    } catch {}
  });

  eventSource.onopen = () => {
    connected = true;
    sseConnectedAt = Date.now();
    document.getElementById('statusDot').className = 'status-dot connected';
    setTimeout(() => seenTraceKeys.clear(), 5000);
  };

  eventSource.onerror = () => {
    connected = false;
    document.getElementById('statusDot').className = 'status-dot disconnected';
  };
}

function handleTraceEvent(data) {
  // Dedup
  if (seenTraceKeys.size > 0) {
    const key = data.message_id + ':' + data.event + ':' + (data.handler || '');
    if (seenTraceKeys.has(key)) return;
  }

  trackTrace(data);
  updateThroughput(data);
  updateErrorBadge();

  // Increment SSE counters for real-time metrics
  statsDelta[data.event] = (statsDelta[data.event] || 0) + 1;
  if (data.event === 'handler.completed' && data.duration_ms != null) {
    latencyDeltaSum += parseFloat(data.duration_ms);
    latencyDeltaCount++;
  }
  scheduleMetricsRefresh();

  if (paused) {
    pauseBuffer.push(data);
    return;
  }

  // Schedule batched DOM updates instead of immediate rendering
  scheduleUpdate(data.message_id, data);
}

// --- Batched Rendering ---
function scheduleUpdate(messageId, eventData) {
  pendingMessageUpdates.add(messageId);
  if (eventData) pendingEventItems.push(eventData);

  if (!rafScheduled) {
    rafScheduled = true;
    requestAnimationFrame(flushUpdates);
  }
}

function flushUpdates() {
  rafScheduled = false;

  // Flush message row updates
  for (const msgId of pendingMessageUpdates) {
    updateMessageRow(msgId, false);

    // Update expanded detail if this message is expanded
    if (msgId === expandedMessageId) {
      renderExpandedDetail(msgId);
    }
  }
  pendingMessageUpdates.clear();

  // Flush event feed items
  for (const data of pendingEventItems) {
    addEventFeedItem(data, false);
  }
  pendingEventItems = [];
}

// --- Scroll-Aware Updates ---
function initScrollListener() {
  const container = document.getElementById('messagesContent');
  container.addEventListener('scroll', () => {
    const wasScrolled = userScrolledMessages;
    userScrolledMessages = container.scrollTop > 60;
    if (!userScrolledMessages && wasScrolled) {
      hideNewMessagesBanner();
    }
  });
}

function showNewMessagesBanner() {
  const banner = document.getElementById('newMessagesBanner');
  const countEl = document.getElementById('newMsgCount');
  if (banner && countEl) {
    countEl.textContent = newMessageCount;
    banner.style.display = '';
  }
}

function hideNewMessagesBanner() {
  const banner = document.getElementById('newMessagesBanner');
  if (banner) banner.style.display = 'none';
  newMessageCount = 0;
}

function scrollToTopMessages() {
  const container = document.getElementById('messagesContent');
  container.scrollTop = 0;
  userScrolledMessages = false;
  hideNewMessagesBanner();
}

// --- Throughput ---
function updateThroughput(data) {
  if (data.event === 'outbox.published') currentSecond.published++;
  if (data.event === 'handler.completed') currentSecond.processed++;
  if (data.event === 'handler.failed' || data.event === 'message.dlq') currentSecond.errors++;
}

function tickThroughput() {
  throughput.published.push(currentSecond.published);
  throughput.published.shift();
  throughput.processed.push(currentSecond.processed);
  throughput.processed.shift();
  throughput.errors.push(currentSecond.errors);
  throughput.errors.shift();

  document.getElementById('ratePublished').textContent = currentSecond.published + '/s';
  document.getElementById('rateProcessed').textContent = currentSecond.processed + '/s';
  document.getElementById('rateErrors').textContent = currentSecond.errors + '/s';

  currentSecond = { published: 0, processed: 0, errors: 0 };
  drawSparkline();
  refreshPipeline();
}

function drawSparkline() {
  const canvas = document.getElementById('sparkline');
  const ctx = canvas.getContext('2d');
  const w = canvas.width;
  const h = canvas.height;

  ctx.clearRect(0, 0, w, h);

  const maxVal = Math.max(1, ...throughput.published, ...throughput.processed);
  const barWidth = w / THROUGHPUT_SECONDS;

  ctx.fillStyle = '#457B9D44';
  for (let i = 0; i < THROUGHPUT_SECONDS; i++) {
    const barH = (throughput.published[i] / maxVal) * h;
    ctx.fillRect(i * barWidth, h - barH, barWidth - 0.5, barH);
  }

  ctx.strokeStyle = '#2A9D8F';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  for (let i = 0; i < THROUGHPUT_SECONDS; i++) {
    const x = i * barWidth + barWidth / 2;
    const y = h - (throughput.processed[i] / maxVal) * h;
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.stroke();

  ctx.fillStyle = '#E76F51';
  for (let i = 0; i < THROUGHPUT_SECONDS; i++) {
    if (throughput.errors[i] > 0) {
      const x = i * barWidth + barWidth / 2;
      const y = h - (throughput.errors[i] / maxVal) * h;
      ctx.beginPath();
      ctx.arc(x, y, 2, 0, Math.PI * 2);
      ctx.fill();
    }
  }
}

// --- Messages Tab ---
function renderAllMessages() {
  const container = document.getElementById('messagesContent');
  const empty = container.querySelector('.feed-empty');
  if (empty) empty.remove();

  // Clear and rebuild — preserve the banner
  container.innerHTML = '<div class="new-messages-banner" id="newMessagesBanner" onclick="scrollToTopMessages()" style="display:none">&uarr; <span id="newMsgCount">0</span> new messages</div>';

  // Render newest-first
  for (const msgId of messageOrder) {
    const row = buildMessageRow(msgId);
    if (row) container.appendChild(row);
  }

  // Trim excess rows
  const rows = container.querySelectorAll('.msg-row');
  for (let i = MAX_ITEMS; i < rows.length; i++) {
    rows[i].remove();
  }
}

function updateMessageRow(messageId, isHistory) {
  const container = document.getElementById('messagesContent');
  const empty = container.querySelector('.feed-empty');
  if (empty) empty.remove();

  // Determine the first real child (skip the sticky banner)
  const banner = document.getElementById('newMessagesBanner');
  const firstChild = banner ? banner.nextElementSibling : container.firstChild;

  // Find existing row
  const existing = container.querySelector(`[data-msg-id="${messageId}"]`);

  if (existing) {
    // Update lifecycle bar in place
    const barEl = existing.querySelector('.lifecycle-bar');
    if (barEl) {
      barEl.innerHTML = buildLifecycleBarHTML(messageId);
    }
    // Move to top if live AND user hasn't scrolled away
    if (!isHistory && !userScrolledMessages) {
      if (firstChild) {
        container.insertBefore(existing, firstChild);
      } else {
        container.appendChild(existing);
      }
    } else if (!isHistory && userScrolledMessages) {
      // User is scrolled — don't reorder, just show banner
      newMessageCount++;
      showNewMessagesBanner();
    }
  } else {
    const row = buildMessageRow(messageId);
    if (row) {
      if (!isHistory && !userScrolledMessages) {
        row.classList.add('new');
        if (firstChild) {
          container.insertBefore(row, firstChild);
        } else {
          container.appendChild(row);
        }
        setTimeout(() => row.classList.remove('new'), 300);
      } else if (!isHistory && userScrolledMessages) {
        // User is scrolled — insert at top but don't scroll
        if (firstChild) {
          container.insertBefore(row, firstChild);
        } else {
          container.appendChild(row);
        }
        newMessageCount++;
        showNewMessagesBanner();
      } else {
        // History — append
        container.appendChild(row);
      }
    }
  }

  // Apply filter
  applyFilters();

  // Trim excess rows (keep banner)
  const rows = container.querySelectorAll('.msg-row');
  if (rows.length > MAX_ITEMS) {
    for (let i = MAX_ITEMS; i < rows.length; i++) {
      rows[i].remove();
    }
  }
}

function buildMessageRow(messageId) {
  const msg = messageById.get(messageId);
  if (!msg) return null;

  const row = document.createElement('div');
  row.className = 'msg-row';
  row.setAttribute('data-msg-id', messageId);
  row.setAttribute('data-stream', msg.stream);
  row.setAttribute('data-type', msg.message_type);
  row.setAttribute('data-has-error', msg.hasError ? '1' : '0');

  const ts = msg.first_ts ? new Date(msg.first_ts) : new Date();
  const timeStr = ts.toLocaleTimeString('en-US', { hour12: false, fractionalSecondDigits: 3 });

  // Summary line
  const summary = document.createElement('div');
  summary.className = 'msg-summary';

  // Duration: find completed stage
  let durationStr = '';
  for (const s of msg.stages) {
    if (s.duration_ms != null) {
      durationStr = s.duration_ms.toFixed(1) + 'ms';
      break;
    }
  }

  summary.innerHTML = `
    <span class="msg-time">${timeStr}</span>
    <div class="msg-info">
      <span class="msg-type">${escapeHtml(msg.message_type)}</span>
      <span class="msg-stream">${escapeHtml(msg.stream)}</span>
      <span class="msg-id">${escapeHtml(messageId)}</span>
    </div>
    <span style="font-family:var(--font-code);font-size:12px;color:var(--text-muted)">${durationStr}</span>
  `;

  row.appendChild(summary);

  // Lifecycle bar
  const bar = document.createElement('div');
  bar.className = 'lifecycle-bar';
  bar.innerHTML = buildLifecycleBarHTML(messageId);
  row.appendChild(bar);

  // Detail panel (hidden by default)
  const detail = document.createElement('div');
  detail.className = 'msg-detail';
  row.appendChild(detail);

  // Click handler
  summary.addEventListener('click', () => toggleMessageExpand(messageId, row));
  bar.addEventListener('click', () => toggleMessageExpand(messageId, row));

  return row;
}

function buildLifecycleBarHTML(messageId) {
  const msg = messageById.get(messageId);
  if (!msg) return '';

  // Sort stages chronologically
  const sorted = [...msg.stages].sort((a, b) => {
    const ta = a.timestamp ? new Date(a.timestamp).getTime() : 0;
    const tb = b.timestamp ? new Date(b.timestamp).getTime() : 0;
    return ta - tb;
  });

  // Separate published (no handler) from handler stages
  const publishedStages = sorted.filter(s => !s.handler || s.event === 'outbox.published');
  const handlerStages = sorted.filter(s => s.handler && s.event !== 'outbox.published');

  // Group handler stages by handler name (preserving order)
  const handlerGroups = new Map();
  for (const s of handlerStages) {
    const h = s.handler;
    if (!handlerGroups.has(h)) handlerGroups.set(h, []);
    handlerGroups.get(h).push(s);
  }

  const isMultiHandler = handlerGroups.size > 1;
  let html = '';

  // Render published marker(s)
  for (let i = 0; i < publishedStages.length; i++) {
    const stage = publishedStages[i];
    const cls = MARKER_CLASS[stage.event] || 'published';
    const icon = MARKER_ICON[stage.event] || '?';
    html += `<div class="lbar-marker ${cls}" title="${escapeHtml(stage.event)}">${icon}</div>`;
  }

  if (isMultiHandler) {
    // Multi-handler: compact segments per handler
    let first = true;
    for (const [handlerName, stages] of handlerGroups) {
      html += `<div class="lbar-line ok"></div>`;
      html += `<div class="lbar-handler-segment">`;
      // Truncated handler name
      const shortName = handlerName.length > 18 ? handlerName.substring(0, 16) + '..' : handlerName;
      html += `<span class="lbar-handler-name" title="${escapeHtml(handlerName)}">${escapeHtml(shortName)}</span>`;
      for (let i = 0; i < stages.length; i++) {
        const stage = stages[i];
        const cls = MARKER_CLASS[stage.event] || 'published';
        const icon = MARKER_ICON[stage.event] || '?';
        html += `<div class="lbar-marker ${cls}" title="${escapeHtml(stage.event)}">${icon}</div>`;
      }
      // Duration after segment if handler.completed present
      const completed = stages.find(s => s.event === 'handler.completed' && s.duration_ms != null);
      if (completed) {
        html += `<span class="lbar-label">${completed.duration_ms.toFixed(1)}ms</span>`;
      }
      // Error indicator
      const failed = stages.find(s => s.event === 'handler.failed');
      if (failed && failed.error) {
        html += `<span class="lbar-label" style="color:var(--accent)">err</span>`;
      }
      // In-progress indicator
      const lastStage = stages[stages.length - 1];
      if (lastStage.event === 'handler.started') {
        html += `<span class="lbar-in-progress">...</span>`;
      }
      html += `</div>`;
    }
  } else {
    // Single handler (or no handler): flat layout as before
    for (let i = 0; i < handlerStages.length; i++) {
      const stage = handlerStages[i];
      const cls = MARKER_CLASS[stage.event] || 'published';
      const icon = MARKER_ICON[stage.event] || '?';

      html += `<div class="lbar-line ${ERROR_EVENTS.has(stage.event) ? 'error' : 'ok'}"></div>`;
      html += `<div class="lbar-marker ${cls}" title="${escapeHtml(stage.event)}">${icon}</div>`;

      if (stage.event === 'handler.completed' && stage.duration_ms != null) {
        html += `<span class="lbar-label">${stage.duration_ms.toFixed(1)}ms</span>`;
      }
      if (stage.event === 'handler.failed' && stage.error) {
        html += `<span class="lbar-label" style="color:var(--accent)">${escapeHtml(stage.error.substring(0, 40))}</span>`;
      }
    }

    // In-progress indicator for single handler
    if (handlerStages.length > 0) {
      const last = handlerStages[handlerStages.length - 1];
      if (last.event === 'handler.started') {
        html += `<div class="lbar-line pending"></div>`;
        html += `<span class="lbar-in-progress">...</span>`;
      }
    }
  }

  return html;
}

function toggleMessageExpand(messageId, row) {
  if (expandedMessageId === messageId) {
    // Collapse
    row.classList.remove('expanded');
    expandedMessageId = null;
    return;
  }

  // Collapse previous
  const prev = document.querySelector('.msg-row.expanded');
  if (prev) prev.classList.remove('expanded');

  expandedMessageId = messageId;
  row.classList.add('expanded');
  renderExpandedDetail(messageId);
}

function renderExpandedDetail(messageId) {
  const row = document.querySelector(`[data-msg-id="${messageId}"]`);
  if (!row) return;
  const detailEl = row.querySelector('.msg-detail');
  if (!detailEl) return;

  const msg = messageById.get(messageId);
  if (!msg) return;

  const sorted = [...msg.stages].sort((a, b) => {
    const ta = a.timestamp ? new Date(a.timestamp).getTime() : 0;
    const tb = b.timestamp ? new Date(b.timestamp).getTime() : 0;
    return ta - tb;
  });

  // Separate published (no handler) from handler stages
  const publishedStages = sorted.filter(s => !s.handler || s.event === 'outbox.published');
  const handlerStages = sorted.filter(s => s.handler && s.event !== 'outbox.published');

  // Group handler stages by handler name (preserving chronological order)
  const handlerGroups = new Map();
  for (const s of handlerStages) {
    const h = s.handler;
    if (!handlerGroups.has(h)) handlerGroups.set(h, []);
    handlerGroups.get(h).push(s);
  }

  const isMultiHandler = handlerGroups.size > 1;

  let html = '';

  // Two-column layout: timeline left, payload/meta right
  html += '<div class="detail-columns">';

  // === LEFT COLUMN: Timeline ===
  html += '<div class="detail-col-left">';
  html += '<div class="detail-section">';
  html += '<div class="detail-section-title">Timeline</div>';
  html += '<div class="detail-timeline">';

  if (isMultiHandler) {
    // Multi-handler: one section per handler
    for (const [handlerName, stages] of handlerGroups) {
      html += '<div class="dtl-handler-group">';
      html += `<div class="dtl-handler-label">${escapeHtml(handlerName)}</div>`;
      html += '<div class="dtl-handler-stages">';

      for (let i = 0; i < stages.length; i++) {
        const stage = stages[i];
        const cls = MARKER_CLASS[stage.event] || 'published';
        const icon = MARKER_ICON[stage.event] || '?';
        const ts = stage.timestamp ? new Date(stage.timestamp) : new Date();
        const timeStr = ts.toLocaleTimeString('en-US', { hour12: false, fractionalSecondDigits: 3 });

        if (i > 0) {
          const lineClass = ERROR_EVENTS.has(stage.event) ? 'error' : 'ok';
          if (stage.duration_ms != null) {
            html += `<span class="dtl-duration">${stage.duration_ms.toFixed(1)}ms</span>`;
          }
          html += `<div class="dtl-line ${lineClass}"></div>`;
        }

        html += `<div class="dtl-stage">`;
        html += `<div class="dtl-marker ${cls}">${icon}</div>`;
        html += `<div class="dtl-event-name">${escapeHtml(stage.event.split('.')[1] || stage.event)}</div>`;
        html += `<div class="dtl-time">${timeStr}</div>`;
        html += `</div>`;
      }

      html += '</div></div>';
    }
  } else {
    // Single handler or no handler: flat layout
    if (handlerStages.length > 0) {
      const handlerName = handlerStages[0].handler;
      html += '<div class="dtl-handler-group">';
      if (handlerName) {
        html += `<div class="dtl-handler-label">${escapeHtml(handlerName)}</div>`;
      }
      html += '<div class="dtl-handler-stages">';

      for (let i = 0; i < handlerStages.length; i++) {
        const stage = handlerStages[i];
        const cls = MARKER_CLASS[stage.event] || 'published';
        const icon = MARKER_ICON[stage.event] || '?';
        const ts = stage.timestamp ? new Date(stage.timestamp) : new Date();
        const timeStr = ts.toLocaleTimeString('en-US', { hour12: false, fractionalSecondDigits: 3 });

        if (i > 0) {
          const lineClass = ERROR_EVENTS.has(stage.event) ? 'error' : 'ok';
          if (stage.duration_ms != null) {
            html += `<span class="dtl-duration">${stage.duration_ms.toFixed(1)}ms</span>`;
          }
          html += `<div class="dtl-line ${lineClass}"></div>`;
        }

        html += `<div class="dtl-stage">`;
        html += `<div class="dtl-marker ${cls}">${icon}</div>`;
        html += `<div class="dtl-event-name">${escapeHtml(stage.event.split('.')[1] || stage.event)}</div>`;
        html += `<div class="dtl-time">${timeStr}</div>`;
        html += `</div>`;
      }

      html += '</div></div>';
    }
  }

  html += '</div></div>';

  // Error (if any) — shown below timeline in left column
  const errorStages = sorted.filter(s => s.error);
  if (errorStages.length > 0) {
    html += '<div class="detail-section">';
    html += '<div class="detail-section-title">Error</div>';
    for (const es of errorStages) {
      html += '<div class="error-detail-box">';
      if (es.handler) html += '<strong>' + escapeHtml(es.handler) + '</strong>: ';
      html += escapeHtml(es.error);
      html += '</div>';
    }
    html += '</div>';
  }

  html += '</div>'; // end detail-col-left

  // === RIGHT COLUMN: Message ID + Payload ===
  html += '<div class="detail-col-right">';

  // Message ID
  html += '<div class="detail-section">';
  html += '<div class="detail-section-title">Message ID <button class="copy-btn" onclick="copyText(\'' + escapeHtml(messageId) + '\', this)">Copy</button></div>';
  html += '<div style="font-family:var(--font-code);font-size:11px;color:var(--text-muted);word-break:break-all">' + escapeHtml(messageId) + '</div>';
  html += '</div>';

  // Payload
  html += '<div class="detail-section">';
  const payloadJson = msg.payload ? JSON.stringify(msg.payload, null, 2) : null;
  if (payloadJson) {
    html += '<div class="detail-section-title">Payload <button class="copy-btn" onclick="copyPayload(\'' + escapeHtml(messageId) + '\', this)">Copy</button></div>';
    html += '<div class="payload-container"><div class="payload-block">' + escapeHtml(payloadJson) + '</div></div>';
  } else {
    html += '<div class="detail-section-title">Payload</div>';
    html += '<div class="payload-empty">Payload not captured for this message</div>';
  }
  html += '</div>';

  html += '</div>'; // end detail-col-right
  html += '</div>'; // end detail-columns

  detailEl.innerHTML = html;
}

// --- Events Tab ---
function addEventFeedItem(data, isHistory) {
  const container = document.getElementById('eventsContent');
  const empty = container.querySelector('.feed-empty');
  if (empty) empty.remove();

  const item = document.createElement('div');
  const statusClass = EVENT_STATUS_CLASS[data.event] || '';
  item.className = `feed-item ${statusClass}` + (isHistory ? '' : ' new');
  item.setAttribute('data-event', data.event || '');
  item.setAttribute('data-stream', data.stream || '');
  item.setAttribute('data-type', data.message_type || '');
  item.setAttribute('data-message-id', data.message_id || '');

  const ts = data.timestamp ? new Date(data.timestamp) : new Date();
  const timeStr = ts.toLocaleTimeString('en-US', { hour12: false, fractionalSecondDigits: 3 });

  let detail = data.stream || '';
  if (data.handler) detail += ' \u2192 ' + data.handler;

  let rightCol = '';
  if (data.duration_ms != null) {
    rightCol = data.duration_ms.toFixed(1) + 'ms';
  }
  if (data.error) {
    rightCol = '<span class="error-text">' + escapeHtml(data.error.substring(0, 80)) + '</span>';
  }
  if (data.metadata && data.metadata.retry_count) {
    rightCol += ' <span style="color:var(--warning)">[retry ' + data.metadata.retry_count + ']</span>';
  }

  item.innerHTML = `
    <span class="timestamp">${timeStr}</span>
    <span class="icon">${EVENT_ICONS[data.event] || '?'}</span>
    <span class="event-type">${escapeHtml(data.event || '')}</span>
    <div class="message-info">
      <span class="message-type">${escapeHtml(data.message_type || '')}</span>
      <span class="message-detail">${escapeHtml(detail)}</span>
    </div>
    <span class="duration">${rightCol}</span>
  `;

  // Click to expand in messages tab
  item.addEventListener('click', () => {
    setViewTab('messages');
    // Find and expand the message
    const msgRow = document.querySelector(`[data-msg-id="${data.message_id}"]`);
    if (msgRow) {
      toggleMessageExpand(data.message_id, msgRow);
      msgRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
  });

  const divider = document.getElementById('historyDivider');
  if (isHistory && divider) {
    // Insert after divider for history items
    if (divider.nextSibling) {
      container.insertBefore(item, divider.nextSibling);
    } else {
      container.appendChild(item);
    }
  } else {
    container.insertBefore(item, container.firstChild);
  }

  // Trim
  const allItems = container.querySelectorAll('.feed-item');
  if (allItems.length > MAX_ITEMS) {
    container.removeChild(allItems[allItems.length - 1]);
  }

  if (!isHistory) {
    setTimeout(() => item.classList.remove('new'), 300);
  }
}

// --- View Tabs ---
function setViewTab(tab) {
  currentTab = tab;
  document.getElementById('tabMessages').classList.toggle('active', tab === 'messages');
  document.getElementById('tabEvents').classList.toggle('active', tab === 'events');
  document.getElementById('tabErrors').classList.toggle('active', tab === 'errors');

  document.getElementById('messagesContent').style.display = (tab === 'messages' || tab === 'errors') ? '' : 'none';
  document.getElementById('eventsContent').style.display = tab === 'events' ? '' : 'none';

  applyFilters();
}

function updateErrorBadge() {
  const badge = document.getElementById('errorBadge');
  if (errorCount > 0) {
    badge.textContent = errorCount > 99 ? '99+' : errorCount;
    badge.style.display = 'inline';
  } else {
    badge.style.display = 'none';
  }
}

// --- Filters ---
function matchesMessageFilters(msg) {
  const streamFilter = document.getElementById('filterStream').value;
  const searchFilter = document.getElementById('filterSearch').value.toLowerCase();

  if (currentTab === 'errors' && !msg.hasError) return false;
  if (streamFilter && msg.stream !== streamFilter) return false;
  if (searchFilter) {
    const searchable = (msg.message_type || '') + ' ' + (msg.stream || '') + ' ' + (msg.message_id || '') + ' ' +
      msg.stages.map(s => s.handler || '').join(' ');
    if (!searchable.toLowerCase().includes(searchFilter)) return false;
  }
  return true;
}

function applyFilters() {
  // Messages tab
  const msgContainer = document.getElementById('messagesContent');
  msgContainer.querySelectorAll('.msg-row').forEach(row => {
    const msgId = row.getAttribute('data-msg-id');
    const msg = messageById.get(msgId);
    if (msg) {
      row.style.display = matchesMessageFilters(msg) ? '' : 'none';
    }
  });

  // Events tab
  const evtContainer = document.getElementById('eventsContent');
  const streamFilter = document.getElementById('filterStream').value;
  const searchFilter = document.getElementById('filterSearch').value.toLowerCase();
  evtContainer.querySelectorAll('.feed-item').forEach(item => {
    const data = {
      stream: item.getAttribute('data-stream'),
      event: item.getAttribute('data-event'),
      message_type: item.getAttribute('data-type'),
      message_id: item.getAttribute('data-message-id'),
    };
    let show = true;
    if (streamFilter && data.stream !== streamFilter) show = false;
    if (searchFilter) {
      const searchable = (data.message_type || '') + ' ' + (data.stream || '') + ' ' + (data.message_id || '');
      if (!searchable.toLowerCase().includes(searchFilter)) show = false;
    }
    item.style.display = show ? '' : 'none';
  });
}

// --- Search by message_id ---
async function searchMessageById(query) {
  if (query.length < 8) return; // Too short for a UUID fragment

  // Check if it looks like a UUID pattern
  if (!/^[0-9a-f-]{8,}$/i.test(query)) return;

  // First check in-memory
  if (messageById.has(query)) return;

  // Fetch from server
  try {
    const res = await fetch('/api/traces?message_id=' + encodeURIComponent(query));
    if (!res.ok) return;
    const data = await res.json();
    if (!data.traces || data.traces.length === 0) return;

    // Process traces
    const reversed = [...data.traces].reverse();
    for (const trace of reversed) {
      trackTrace(trace);
    }
    updateMessageRow(query, true);
  } catch (e) {
    console.error('Search failed:', e);
  }
}

function scrollToTop() {
  const container = currentTab === 'events'
    ? document.getElementById('eventsContent')
    : document.getElementById('messagesContent');
  container.scrollTop = 0;
  document.getElementById('newEventsBadge').style.display = 'none';
}

function updateDomainFilter() {
  const select = document.getElementById('filterDomain');
  const current = select.value;
  select.innerHTML = '<option value="">All domains</option>';
  knownDomains.forEach(d => {
    const opt = document.createElement('option');
    opt.value = d;
    opt.textContent = d;
    select.appendChild(opt);
  });
  select.value = current;
}

function updateStreamFilter() {
  const select = document.getElementById('filterStream');
  const current = select.value;
  select.innerHTML = '<option value="">All streams</option>';
  knownStreams.forEach(s => {
    const opt = document.createElement('option');
    opt.value = s;
    opt.textContent = s;
    select.appendChild(opt);
  });
  select.value = current;
}

// --- Pause ---
function togglePause() {
  paused = !paused;
  const btn = document.getElementById('pauseBtn');
  if (paused) {
    btn.textContent = '\u25b6 Resume';
    btn.classList.add('active');
  } else {
    btn.textContent = '\u23f8 Pause';
    btn.classList.remove('active');
    // Batch resume: schedule all buffered updates
    for (const data of pauseBuffer) {
      scheduleUpdate(data.message_id, data);
    }
    pauseBuffer = [];
  }
}

// --- Reset ---
async function resetDashboard() {
  if (!confirm('Clear all trace history and reset counters?')) return;

  try {
    await fetch('/api/traces', { method: 'DELETE' });
  } catch (e) {
    console.error('Failed to clear trace stream:', e);
  }

  // Clear client-side state
  tracesByMessageId.clear();
  messageById.clear();
  messageOrder.length = 0;
  errorCount = 0;
  expandedMessageId = null;
  seenTraceKeys.clear();
  pendingMessageUpdates.clear();
  pendingEventItems = [];
  userScrolledMessages = false;
  newMessageCount = 0;
  statsBase = null;
  statsDelta = {};
  latencyDeltaSum = 0;
  latencyDeltaCount = 0;

  throughput.published.fill(0);
  throughput.processed.fill(0);
  throughput.errors.fill(0);
  currentSecond = { published: 0, processed: 0, errors: 0 };

  queueDepth.outbox.fill(0);
  queueDepth.stream.fill(0);
  queueDepth.consumer.fill(0);
  latestQueueDepth = { outbox: 0, stream: 0, consumer: 0 };
  queueDepthDetail = { outbox: {}, streams: {} };

  document.getElementById('messagesContent').innerHTML = '<div class="new-messages-banner" id="newMessagesBanner" onclick="scrollToTopMessages()" style="display:none">&uarr; <span id="newMsgCount">0</span> new messages</div><div class="feed-empty">History cleared. Waiting for new events...</div>';
  document.getElementById('eventsContent').innerHTML = '<div class="feed-empty">History cleared. Waiting for new events...</div>';

  updateErrorBadge();
  drawSparkline();
  drawQueueSparkline();
  await loadStats();
  await pollInfrastructure();
  await pollQueueDepth();
}

// --- Copy helpers ---
function copyText(text, btn) {
  navigator.clipboard.writeText(text).then(() => {
    btn.textContent = '\u2713 Copied';
    btn.classList.add('copied');
    setTimeout(() => {
      btn.textContent = 'Copy';
      btn.classList.remove('copied');
    }, 2000);
  });
}

function copyPayload(messageId, btn) {
  const msg = messageById.get(messageId);
  if (msg && msg.payload) {
    const text = JSON.stringify(msg.payload, null, 2);
    copyText(text, btn);
  }
}

// --- Infrastructure polling ---
async function pollInfrastructure() {
  try {
    const res = await fetch('/api/health');
    const data = await res.json();
    const redis = data.infrastructure?.redis || {};

    document.getElementById('infraGrid').innerHTML = `
      <div class="infra-item">
        <span class="status-dot ${redis.healthy ? 'connected' : 'disconnected'}"></span>
        <span class="label">Redis</span>
        <span class="value">${redis.healthy ? 'Healthy' : 'Down'}</span>
      </div>
      <div class="infra-item">
        <span class="label">Memory:</span>
        <span class="value">${redis.memory || '?'}</span>
      </div>
      <div class="infra-item">
        <span class="label">Ops/s:</span>
        <span class="value">${redis.ops_per_sec ?? '?'}</span>
      </div>
      <div class="infra-item">
        <span class="label">Clients:</span>
        <span class="value">${redis.connected_clients ?? '?'}</span>
      </div>
      <div class="infra-item">
        <span class="label">Uptime:</span>
        <span class="value">${formatUptime(redis.uptime_seconds)}</span>
      </div>
    `;

  } catch (e) {
    console.error('Infrastructure poll failed:', e);
  }
}

// --- Queue Depth Polling ---
async function pollQueueDepth() {
  try {
    const res = await fetch('/api/queue-depth');
    if (!res.ok) return;
    const data = await res.json();

    // Apply domain filter to outbox counts
    const domainFilter = document.getElementById('filterDomain').value;
    let outboxPending = 0;
    if (domainFilter) {
      const domainCounts = (data.outbox || {})[domainFilter];
      if (domainCounts) {
        outboxPending = (domainCounts.pending || 0) + (domainCounts.processing || 0);
      }
    } else {
      outboxPending = data.totals?.outbox_pending || 0;
    }

    const streamDepth = data.totals?.stream_depth || 0;
    const consumerPending = data.totals?.consumer_pending || 0;

    latestQueueDepth = {
      outbox: outboxPending,
      stream: streamDepth,
      consumer: consumerPending,
    };
    queueDepthDetail = {
      outbox: data.outbox || {},
      streams: data.streams || {},
    };

    updateBackpressureGauges();
    updateConsumerLagTable();

    const now = new Date();
    const timeStr = now.toLocaleTimeString('en-US', { hour12: false });
    const el = document.getElementById('bpLastUpdated');
    if (el) el.textContent = 'updated ' + timeStr;

  } catch (e) {
    console.error('Queue depth poll failed:', e);
  }
}

function tickQueueDepth() {
  queueDepth.outbox.push(latestQueueDepth.outbox);
  queueDepth.outbox.shift();
  queueDepth.stream.push(latestQueueDepth.stream);
  queueDepth.stream.shift();
  queueDepth.consumer.push(latestQueueDepth.consumer);
  queueDepth.consumer.shift();
  drawQueueSparkline();
}

function updateBackpressureGauges() {
  const WARN_THRESHOLD = 100;
  const CRITICAL_THRESHOLD = 1000;

  function setGauge(valueId, gaugeId, value) {
    const el = document.getElementById(valueId);
    const gauge = document.getElementById(gaugeId);
    if (!el) return;

    el.textContent = value.toLocaleString();

    let severity = 'ok';
    if (value >= CRITICAL_THRESHOLD) severity = 'critical';
    else if (value >= WARN_THRESHOLD) severity = 'warn';

    el.className = 'bp-value ' + severity;
    if (gauge) {
      gauge.className = 'bp-gauge' + (severity !== 'ok' ? ' ' + severity : '');
    }
  }

  setGauge('bpOutboxValue', 'bpOutbox', latestQueueDepth.outbox);
  setGauge('bpStreamValue', 'bpStream', latestQueueDepth.stream);
  setGauge('bpConsumerValue', 'bpConsumer', latestQueueDepth.consumer);

  // Per-domain detail in subtitle
  const outboxDetail = document.getElementById('bpOutboxDetail');
  if (outboxDetail) {
    const parts = Object.entries(queueDepthDetail.outbox)
      .filter(([_, v]) => (v.pending || 0) + (v.processing || 0) > 0)
      .map(([domain, v]) => domain + ': ' + ((v.pending || 0) + (v.processing || 0)));
    outboxDetail.textContent = parts.length > 0 ? parts.join(', ') : 'waiting to publish';
  }
}

function drawQueueSparkline() {
  const canvas = document.getElementById('queueSparkline');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  const w = canvas.width;
  const h = canvas.height;

  ctx.clearRect(0, 0, w, h);

  const maxVal = Math.max(
    1,
    ...queueDepth.outbox,
    ...queueDepth.stream,
    ...queueDepth.consumer
  );
  const barWidth = w / QUEUE_DEPTH_SECONDS;

  // Outbox pending (orange area)
  ctx.fillStyle = 'rgba(231, 111, 81, 0.3)';
  ctx.strokeStyle = '#E76F51';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(0, h);
  for (let i = 0; i < QUEUE_DEPTH_SECONDS; i++) {
    const x = i * barWidth + barWidth / 2;
    const y = h - (queueDepth.outbox[i] / maxVal) * h;
    ctx.lineTo(x, y);
  }
  ctx.lineTo(w, h);
  ctx.closePath();
  ctx.fill();
  // Stroke the top edge only
  ctx.beginPath();
  for (let i = 0; i < QUEUE_DEPTH_SECONDS; i++) {
    const x = i * barWidth + barWidth / 2;
    const y = h - (queueDepth.outbox[i] / maxVal) * h;
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.stroke();

  // Stream depth (blue area)
  ctx.fillStyle = 'rgba(69, 123, 157, 0.3)';
  ctx.strokeStyle = '#457B9D';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(0, h);
  for (let i = 0; i < QUEUE_DEPTH_SECONDS; i++) {
    const x = i * barWidth + barWidth / 2;
    const y = h - (queueDepth.stream[i] / maxVal) * h;
    ctx.lineTo(x, y);
  }
  ctx.lineTo(w, h);
  ctx.closePath();
  ctx.fill();
  ctx.beginPath();
  for (let i = 0; i < QUEUE_DEPTH_SECONDS; i++) {
    const x = i * barWidth + barWidth / 2;
    const y = h - (queueDepth.stream[i] / maxVal) * h;
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.stroke();

  // Consumer lag (yellow line)
  ctx.strokeStyle = '#E9C46A';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  for (let i = 0; i < QUEUE_DEPTH_SECONDS; i++) {
    const x = i * barWidth + barWidth / 2;
    const y = h - (queueDepth.consumer[i] / maxVal) * h;
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.stroke();
}

function updateConsumerLagTable() {
  const tbody = document.getElementById('lagTableBody');
  if (!tbody) return;

  const streams = queueDepthDetail.streams;
  const streamNames = Object.keys(streams).sort();

  if (streamNames.length === 0) {
    tbody.innerHTML = '<tr><td colspan="5" style="text-align:center;color:var(--text-muted)">No active streams</td></tr>';
    return;
  }

  // Find max XLEN for lag bar proportions
  let maxLen = 1;
  for (const name of streamNames) {
    maxLen = Math.max(maxLen, streams[name].length || 0);
  }

  let html = '';
  for (const name of streamNames) {
    const s = streams[name];
    const groups = Object.entries(s.consumer_groups || {});

    if (groups.length === 0) {
      html += '<tr>';
      html += '<td>' + escapeHtml(name) + '</td>';
      html += '<td>' + (s.length || 0).toLocaleString() + '</td>';
      html += '<td style="color:var(--text-muted)">--</td>';
      html += '<td>--</td>';
      html += '<td><div class="lag-bar-bg"><div class="lag-bar-fill ok" style="width:0%"></div></div></td>';
      html += '</tr>';
    } else {
      for (let i = 0; i < groups.length; i++) {
        const [gname, gdata] = groups[i];
        const pending = gdata.pending || 0;
        const pct = Math.min(100, (pending / maxLen) * 100);
        const severity = pending >= 1000 ? 'critical' : pending >= 100 ? 'warn' : 'ok';
        const color = severity === 'critical' ? 'var(--accent)' : severity === 'warn' ? '#E65100' : 'var(--text)';

        html += '<tr>';
        html += '<td>' + (i === 0 ? escapeHtml(name) : '') + '</td>';
        html += '<td>' + (i === 0 ? (s.length || 0).toLocaleString() : '') + '</td>';
        html += '<td>' + escapeHtml(gname) + '</td>';
        html += '<td style="color:' + color + '">' + pending.toLocaleString() + '</td>';
        html += '<td><div class="lag-bar-bg"><div class="lag-bar-fill ' + severity + '" style="width:' + pct.toFixed(1) + '%"></div></div></td>';
        html += '</tr>';
      }
    }
  }

  tbody.innerHTML = html;
}

// --- Utils ---
function escapeHtml(str) {
  const div = document.createElement('div');
  div.textContent = str;
  return div.innerHTML;
}

function formatUptime(seconds) {
  if (!seconds) return '?';
  const d = Math.floor(seconds / 86400);
  const h = Math.floor((seconds % 86400) / 3600);
  const m = Math.floor((seconds % 3600) / 60);
  if (d > 0) return d + 'd ' + h + 'h';
  if (h > 0) return h + 'h ' + m + 'm';
  return m + 'm';
}

// --- Filter change handlers ---
document.getElementById('filterDomain').addEventListener('change', () => {
  if (eventSource) eventSource.close();
  connectSSE();
  pollQueueDepth();
});

document.getElementById('filterStream').addEventListener('change', applyFilters);

// Search with debounced server lookup for message IDs
let searchTimeout = null;
document.getElementById('filterSearch').addEventListener('input', () => {
  applyFilters();
  clearTimeout(searchTimeout);
  const q = document.getElementById('filterSearch').value.trim();
  if (q.length >= 8) {
    searchTimeout = setTimeout(() => searchMessageById(q), 500);
  }
});

// --- Init ---
async function init() {
  initScrollListener();
  await loadHistory();
  await loadStats();
  connectSSE();
  pollInfrastructure();
  pollQueueDepth();
  setInterval(tickThroughput, 1000);
  setInterval(tickQueueDepth, 1000);
  setInterval(() => { loadStats(); pollInfrastructure(); }, 5000);
  setInterval(pollQueueDepth, 2000);
  drawSparkline();
  drawQueueSparkline();
}
init();
</script>
</body>
</html>
