<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Protean Observatory</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Lato:wght@400;600;800&family=Roboto+Mono:wght@400;500&display=swap" rel="stylesheet">
<style>
:root {
  --primary: #1D3557;
  --secondary: #457B9D;
  --accent: #E76F51;
  --success: #2A9D8F;
  --warning: #E9C46A;
  --bg: #F8F9FA;
  --surface: #FFFFFF;
  --text: #1D3557;
  --text-muted: #6C757D;
  --border: #DEE2E6;
  --font-text: 'Lato', sans-serif;
  --font-code: 'Roboto Mono', monospace;
}

@media (prefers-color-scheme: dark) {
  :root {
    --primary: #A8DADC;
    --secondary: #457B9D;
    --accent: #E76F51;
    --success: #2A9D8F;
    --warning: #E9C46A;
    --bg: #0D1B2A;
    --surface: #1B2838;
    --text: #E0E0E0;
    --text-muted: #8899AA;
    --border: #2A3A4A;
  }
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  font-family: var(--font-text);
  background: var(--bg);
  color: var(--text);
  line-height: 1.5;
}

/* Header */
.header {
  background: #1D3557;
  color: white;
  padding: 12px 24px;
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.header-left {
  display: flex;
  align-items: center;
  gap: 12px;
}

.header-left .logo {
  font-size: 18px;
  font-weight: 800;
  letter-spacing: -0.025em;
}

.header-left .subtitle {
  font-size: 13px;
  opacity: 0.7;
}

.header-right {
  display: flex;
  align-items: center;
  gap: 12px;
}

.header select {
  background: rgba(255,255,255,0.15);
  color: white;
  border: 1px solid rgba(255,255,255,0.3);
  padding: 4px 8px;
  border-radius: 4px;
  font-family: var(--font-text);
  font-size: 13px;
  cursor: pointer;
}

.header select option { color: #333; background: white; }

.btn {
  background: rgba(255,255,255,0.15);
  color: white;
  border: 1px solid rgba(255,255,255,0.3);
  padding: 4px 12px;
  border-radius: 4px;
  font-family: var(--font-text);
  font-size: 13px;
  cursor: pointer;
  transition: background 0.15s;
}

.btn:hover { background: rgba(255,255,255,0.25); }
.btn.active { background: var(--accent); border-color: var(--accent); }

/* Connection status */
.status-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  display: inline-block;
}

.status-dot.connected { background: var(--success); }
.status-dot.disconnected { background: var(--accent); }

/* Main layout */
.main {
  max-width: 1400px;
  margin: 0 auto;
  padding: 16px 24px;
  display: flex;
  flex-direction: column;
  gap: 16px;
}

/* Card */
.card {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 8px;
  overflow: hidden;
}

.card-header {
  padding: 10px 16px;
  font-size: 13px;
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.card-body { padding: 16px; }

/* Summary Metrics Bar */
.summary-bar {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 14px 20px;
  gap: 16px;
  flex-wrap: wrap;
}

.summary-metrics {
  display: flex;
  gap: 32px;
  flex-wrap: wrap;
}

.summary-metric {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.summary-metric .metric-label {
  font-size: 11px;
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.summary-metric .metric-value {
  font-family: var(--font-code);
  font-size: 22px;
  font-weight: 500;
}

.summary-metric .metric-value.good { color: var(--success); }
.summary-metric .metric-value.warn { color: #E65100; }
.summary-metric .metric-value.bad { color: var(--accent); }

.window-selector {
  display: flex;
  gap: 4px;
}

.window-btn {
  background: var(--bg);
  color: var(--text-muted);
  border: 1px solid var(--border);
  padding: 4px 12px;
  border-radius: 4px;
  font-family: var(--font-code);
  font-size: 12px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.15s;
}

.window-btn:hover { border-color: var(--secondary); color: var(--text); }
.window-btn.active {
  background: var(--secondary);
  color: white;
  border-color: var(--secondary);
}

/* Pipeline */
.pipeline {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  padding: 20px 16px;
  flex-wrap: wrap;
}

.pipeline-stage {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
}

.pipeline-stage .label {
  font-size: 11px;
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
}

.pipeline-stage .count-box {
  width: 80px;
  height: 48px;
  border-radius: 6px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-family: var(--font-code);
  font-size: 20px;
  font-weight: 500;
  transition: all 0.3s;
}

.pipeline-stage .rate-label {
  font-size: 10px;
  color: var(--text-muted);
  font-family: var(--font-code);
}

.pipeline-stage .count-box.published { background: #E8F4FD; color: var(--secondary); border: 2px solid var(--secondary); }
.pipeline-stage .count-box.handling { background: #FFF3E0; color: #E65100; border: 2px solid var(--warning); }
.pipeline-stage .count-box.done { background: #E8F5E9; color: var(--success); border: 2px solid var(--success); }
.pipeline-stage .count-box.failed { background: #FFEBEE; color: var(--accent); border: 2px solid var(--accent); }

.pipeline-arrow {
  color: var(--text-muted);
  font-size: 20px;
  margin-top: 14px;
}

@media (prefers-color-scheme: dark) {
  .pipeline-stage .count-box.published { background: rgba(69,123,157,0.2); }
  .pipeline-stage .count-box.handling { background: rgba(233,196,106,0.15); }
  .pipeline-stage .count-box.done { background: rgba(42,157,143,0.15); }
  .pipeline-stage .count-box.failed { background: rgba(231,111,81,0.15); }
}

/* Throughput chart */
.sparkline-container {
  padding: 12px 16px;
}

.sparkline-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 8px;
}

.sparkline-header .chart-title {
  font-size: 13px;
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.sparkline-stats {
  display: flex;
  gap: 24px;
  margin-top: 8px;
  font-size: 13px;
}

.sparkline-stats .stat-label { color: var(--text-muted); }
.sparkline-stats .stat-value { font-family: var(--font-code); font-weight: 500; }

.time-labels {
  display: flex;
  justify-content: space-between;
  font-size: 10px;
  color: var(--text-muted);
  font-family: var(--font-code);
  padding: 2px 0 0;
}

/* Feed controls */
.feed-controls {
  display: flex;
  gap: 8px;
  align-items: center;
}

.feed-controls select, .feed-controls input {
  padding: 3px 8px;
  border: 1px solid var(--border);
  border-radius: 4px;
  font-family: var(--font-text);
  font-size: 12px;
  background: var(--surface);
  color: var(--text);
}

.feed-controls input { width: 180px; }

.feed-tab {
  background: none;
  border: none;
  padding: 3px 10px;
  font-family: var(--font-text);
  font-size: 12px;
  color: var(--text-muted);
  cursor: pointer;
  border-bottom: 2px solid transparent;
  transition: all 0.15s;
}

.feed-tab:hover { color: var(--text); }
.feed-tab.active {
  color: var(--text);
  border-bottom-color: var(--secondary);
  font-weight: 600;
}

.feed-tab .error-badge {
  background: var(--accent);
  color: white;
  font-size: 10px;
  padding: 1px 5px;
  border-radius: 8px;
  margin-left: 4px;
  font-weight: 600;
}

/* Content area for both tabs */
.tab-content {
  max-height: 600px;
  overflow-y: auto;
  scroll-behavior: smooth;
}

.feed-empty {
  padding: 40px;
  text-align: center;
  color: var(--text-muted);
  font-size: 14px;
}

.feed-divider {
  padding: 6px 16px;
  font-size: 11px;
  color: var(--text-muted);
  text-align: center;
  border-bottom: 1px solid var(--border);
  background: var(--bg);
  font-family: var(--font-code);
  letter-spacing: 0.05em;
}

/* --- Messages Tab --- */
.msg-row {
  border-bottom: 1px solid var(--border);
  cursor: pointer;
  transition: background 0.15s;
}

.msg-row:hover { background: var(--bg); }
.msg-row.new { animation: fadeIn 0.3s ease-out; }

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(-4px); }
  to { opacity: 1; transform: translateY(0); }
}

.msg-summary {
  display: grid;
  grid-template-columns: 90px 1fr auto;
  align-items: center;
  gap: 12px;
  padding: 10px 16px;
}

.msg-summary .msg-time {
  font-family: var(--font-code);
  font-size: 12px;
  color: var(--text-muted);
  white-space: nowrap;
}

.msg-summary .msg-info {
  display: flex;
  flex-direction: column;
  gap: 4px;
  min-width: 0;
}

.msg-summary .msg-type {
  font-weight: 600;
  font-size: 13px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.msg-summary .msg-stream {
  font-family: var(--font-code);
  font-size: 11px;
  color: var(--text-muted);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.msg-summary .msg-id {
  font-family: var(--font-code);
  font-size: 10px;
  color: var(--text-muted);
  opacity: 0.7;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

/* Horizontal lifecycle bar */
.lifecycle-bar {
  display: flex;
  align-items: center;
  gap: 0;
  padding: 2px 16px 10px;
}

.lbar-stage {
  display: flex;
  align-items: center;
  gap: 0;
}

.lbar-marker {
  width: 14px;
  height: 14px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 9px;
  font-weight: 700;
  color: white;
  flex-shrink: 0;
  position: relative;
}

.lbar-marker.published { background: var(--secondary); }
.lbar-marker.started { background: var(--warning); color: #333; }
.lbar-marker.completed { background: var(--success); }
.lbar-marker.acked { background: var(--success); }
.lbar-marker.failed { background: var(--accent); }
.lbar-marker.nacked { background: var(--warning); color: #333; }
.lbar-marker.dlq { background: var(--accent); }

.lbar-line {
  width: 24px;
  height: 2px;
  flex-shrink: 0;
}

.lbar-line.ok { background: var(--success); }
.lbar-line.pending { background: var(--border); }
.lbar-line.error { background: var(--accent); }
.lbar-line.warn { background: var(--warning); }

.lbar-label {
  font-family: var(--font-code);
  font-size: 10px;
  color: var(--text-muted);
  margin-left: 4px;
  white-space: nowrap;
}

.lbar-in-progress {
  font-family: var(--font-code);
  font-size: 10px;
  color: var(--text-muted);
  margin-left: 4px;
  animation: blink 1.2s infinite;
}

@keyframes blink {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.3; }
}

/* Expanded message detail */
.msg-detail {
  display: none;
  border-top: 1px solid var(--border);
  background: var(--bg);
  padding: 16px;
}

.msg-row.expanded .msg-detail { display: block; }
.msg-row.expanded { background: var(--bg); }

.detail-columns {
  display: flex;
  gap: 20px;
  align-items: flex-start;
}

.detail-col-left {
  flex: 1;
  min-width: 0;
}

.detail-col-right {
  width: 340px;
  flex-shrink: 0;
}

@media (max-width: 900px) {
  .detail-columns { flex-direction: column; }
  .detail-col-right { width: 100%; }
}

.detail-section {
  margin-bottom: 16px;
}

.detail-section:last-child { margin-bottom: 0; }

.detail-section-title {
  font-size: 11px;
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  margin-bottom: 8px;
  display: flex;
  align-items: center;
  justify-content: space-between;
}

/* Detailed horizontal timeline */
.detail-timeline {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.detail-timeline-row {
  display: flex;
  align-items: center;
  gap: 0;
}

.dtl-stage {
  display: flex;
  align-items: center;
  flex-direction: column;
  min-width: 70px;
  text-align: center;
}

.dtl-marker {
  width: 18px;
  height: 18px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 10px;
  font-weight: 700;
  color: white;
}

.dtl-marker.published { background: var(--secondary); }
.dtl-marker.started { background: var(--warning); color: #333; }
.dtl-marker.completed { background: var(--success); }
.dtl-marker.acked { background: var(--success); }
.dtl-marker.failed { background: var(--accent); }
.dtl-marker.nacked { background: var(--warning); color: #333; }
.dtl-marker.dlq { background: var(--accent); }

.dtl-event-name {
  font-family: var(--font-code);
  font-size: 10px;
  color: var(--text);
  margin-top: 2px;
  font-weight: 500;
}

.dtl-time {
  font-family: var(--font-code);
  font-size: 10px;
  color: var(--text-muted);
}

.dtl-handler {
  font-size: 11px;
  color: var(--text-muted);
}

.dtl-line {
  flex: 1;
  height: 2px;
  min-width: 20px;
  margin: 0 4px;
  margin-bottom: 26px;
}

.dtl-line.ok { background: var(--success); }
.dtl-line.error { background: var(--accent); }
.dtl-line.pending { background: var(--border); }

.dtl-duration {
  font-family: var(--font-code);
  font-size: 10px;
  color: var(--text-muted);
  margin-bottom: 26px;
  margin-left: 4px;
  margin-right: 4px;
  white-space: nowrap;
}

/* Multi-handler expanded timeline */
.dtl-published-row {
  display: flex;
  align-items: center;
  gap: 0;
  padding: 4px 0;
}

.dtl-handler-group {
  padding: 6px 0 4px;
  border-top: 1px solid var(--border);
}

.dtl-handler-group:first-of-type {
  border-top: none;
}

.dtl-handler-label {
  font-family: var(--font-code);
  font-size: 11px;
  font-weight: 600;
  color: var(--text);
  margin-bottom: 4px;
  padding-left: 2px;
}

.dtl-handler-stages {
  display: flex;
  align-items: center;
  gap: 0;
  padding-left: 8px;
}

/* Summary bar handler segments */
.lbar-handler-segment {
  display: flex;
  align-items: center;
  gap: 0;
}

.lbar-handler-name {
  font-family: var(--font-code);
  font-size: 9px;
  color: var(--text-muted);
  margin-right: 4px;
  max-width: 120px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

/* New messages banner */
.new-messages-banner {
  position: sticky;
  top: 0;
  z-index: 10;
  background: var(--secondary);
  color: white;
  text-align: center;
  padding: 6px 16px;
  font-size: 13px;
  font-weight: 600;
  cursor: pointer;
  border-radius: 0 0 8px 8px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.2);
  transition: opacity 0.2s;
}

.new-messages-banner:hover {
  opacity: 0.9;
}

/* Payload viewer */
.payload-container {
  position: relative;
}

.payload-block {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 12px;
  font-family: var(--font-code);
  font-size: 12px;
  line-height: 1.6;
  white-space: pre-wrap;
  word-break: break-all;
  max-height: 300px;
  overflow-y: auto;
  color: var(--text);
}

.copy-btn {
  background: var(--bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 3px 10px;
  font-family: var(--font-code);
  font-size: 11px;
  color: var(--text-muted);
  cursor: pointer;
  transition: all 0.15s;
}

.copy-btn:hover { border-color: var(--secondary); color: var(--text); }
.copy-btn.copied { background: var(--success); color: white; border-color: var(--success); }

.payload-empty {
  font-size: 12px;
  color: var(--text-muted);
  font-style: italic;
}

/* Error detail */
.error-detail-box {
  background: #FFF5F5;
  border: 1px solid var(--accent);
  border-radius: 6px;
  padding: 10px 12px;
  font-family: var(--font-code);
  font-size: 12px;
  color: var(--accent);
  line-height: 1.5;
}

@media (prefers-color-scheme: dark) {
  .error-detail-box { background: rgba(231,111,81,0.1); }
}

/* Events tab - reuses old feed styles */
.feed-item {
  padding: 8px 16px;
  border-bottom: 1px solid var(--border);
  border-left: 3px solid transparent;
  transition: background 0.15s;
  cursor: pointer;
  display: grid;
  grid-template-columns: 90px 20px 140px 1fr auto;
  align-items: start;
  gap: 8px;
  font-size: 13px;
}

.feed-item:hover { background: var(--bg); }
.feed-item.selected { background: var(--bg); }
.feed-item.status-ok { border-left-color: var(--success); }
.feed-item.status-error { border-left-color: var(--accent); }
.feed-item.status-retry { border-left-color: var(--warning); }
.feed-item.new { animation: fadeIn 0.3s ease-out; }

.feed-item .timestamp {
  font-family: var(--font-code);
  font-size: 12px;
  color: var(--text-muted);
  white-space: nowrap;
}

.feed-item .icon { font-size: 14px; }
.feed-item .event-type {
  font-family: var(--font-code);
  font-size: 12px;
  font-weight: 500;
}

.feed-item .message-info {
  display: flex;
  flex-direction: column;
  gap: 2px;
  min-width: 0;
}

.feed-item .message-type {
  font-weight: 600;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.feed-item .message-detail {
  font-size: 12px;
  color: var(--text-muted);
  font-family: var(--font-code);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.feed-item .duration {
  font-family: var(--font-code);
  font-size: 12px;
  color: var(--text-muted);
  white-space: nowrap;
}

.feed-item .error-text {
  color: var(--accent);
  font-size: 12px;
}

/* Infrastructure */
.infra-grid {
  display: flex;
  flex-wrap: wrap;
  gap: 16px;
  font-size: 13px;
}

.infra-item {
  display: flex;
  align-items: center;
  gap: 6px;
}

.infra-item .label { color: var(--text-muted); }
.infra-item .value { font-family: var(--font-code); font-weight: 500; }

/* New events badge */
.new-events-badge {
  display: none;
  position: fixed;
  bottom: 24px;
  left: 50%;
  transform: translateX(-50%);
  background: var(--primary);
  color: white;
  padding: 8px 16px;
  border-radius: 20px;
  font-size: 13px;
  cursor: pointer;
  z-index: 100;
  box-shadow: 0 2px 8px rgba(0,0,0,0.2);
}
</style>
</head>
<body>

<!-- Header -->
<div class="header">
  <div class="header-left">
    <span class="logo">&#9670; Protean Observatory</span>
    <span class="subtitle">Real-time message flow</span>
  </div>
  <div class="header-right">
    <span class="status-dot disconnected" id="statusDot"></span>
    <select id="filterDomain">
      <option value="">All domains</option>
    </select>
    <button class="btn" id="pauseBtn" onclick="togglePause()">&#9208; Pause</button>
    <button class="btn" id="resetBtn" onclick="resetDashboard()">&#8634; Reset</button>
  </div>
</div>

<!-- Main -->
<div class="main">

  <!-- Summary Metrics Bar -->
  <div class="card">
    <div class="summary-bar">
      <div class="summary-metrics">
        <div class="summary-metric">
          <span class="metric-label">Throughput</span>
          <span class="metric-value good" id="metricThroughput">--</span>
        </div>
        <div class="summary-metric">
          <span class="metric-label">Error Rate</span>
          <span class="metric-value good" id="metricErrorRate">--</span>
        </div>
        <div class="summary-metric">
          <span class="metric-label">Avg Latency</span>
          <span class="metric-value good" id="metricLatency">--</span>
        </div>
        <div class="summary-metric">
          <span class="metric-label">In Flight</span>
          <span class="metric-value good" id="metricInFlight">0</span>
        </div>
      </div>
      <div class="window-selector">
        <button class="window-btn active" data-window="5m" onclick="setWindow('5m')">5m</button>
        <button class="window-btn" data-window="15m" onclick="setWindow('15m')">15m</button>
        <button class="window-btn" data-window="1h" onclick="setWindow('1h')">1h</button>
        <button class="window-btn" data-window="24h" onclick="setWindow('24h')">24h</button>
        <button class="window-btn" data-window="7d" onclick="setWindow('7d')">7d</button>
      </div>
    </div>
  </div>

  <!-- Pipeline -->
  <div class="card">
    <div class="pipeline">
      <div class="pipeline-stage">
        <span class="label">Published</span>
        <div class="count-box published" id="pipePublished">0</div>
        <span class="rate-label" id="ratePublishedPipe">&nbsp;</span>
      </div>
      <span class="pipeline-arrow">&#9654;</span>
      <div class="pipeline-stage">
        <span class="label">Handling</span>
        <div class="count-box handling" id="pipeHandling">0</div>
        <span class="rate-label" id="rateHandling">&nbsp;</span>
      </div>
      <span class="pipeline-arrow">&#9654;</span>
      <div class="pipeline-stage">
        <span class="label">Done</span>
        <div class="count-box done" id="pipeDone">0</div>
        <span class="rate-label" id="rateDone">&nbsp;</span>
      </div>
      <span class="pipeline-arrow">&#9654;</span>
      <div class="pipeline-stage">
        <span class="label">Failed</span>
        <div class="count-box failed" id="pipeFailed">0</div>
        <span class="rate-label" id="rateFailed">&nbsp;</span>
      </div>
    </div>
  </div>

  <!-- Throughput Chart -->
  <div class="card">
    <div class="sparkline-container">
      <div class="sparkline-header">
        <span class="chart-title">Throughput (5 min)</span>
        <div class="sparkline-stats">
          <div><span class="stat-label">Published:</span> <span class="stat-value" id="ratePublished">0/s</span></div>
          <div><span class="stat-label">Processed:</span> <span class="stat-value" id="rateProcessed">0/s</span></div>
          <div><span class="stat-label">Errors:</span> <span class="stat-value" id="rateErrors">0/s</span></div>
        </div>
      </div>
      <canvas id="sparkline" width="1000" height="80"></canvas>
      <div class="time-labels">
        <span>5m ago</span>
        <span>4m</span>
        <span>3m</span>
        <span>2m</span>
        <span>1m</span>
        <span>now</span>
      </div>
    </div>
  </div>

  <!-- Messages / Events -->
  <div class="card">
    <div class="card-header">
      <div style="display:flex; align-items:center; gap:8px;">
        <button class="feed-tab active" id="tabMessages" onclick="setViewTab('messages')">Messages</button>
        <button class="feed-tab" id="tabEvents" onclick="setViewTab('events')">Events</button>
        <button class="feed-tab" id="tabErrors" onclick="setViewTab('errors')">Errors <span class="error-badge" id="errorBadge" style="display:none">0</span></button>
      </div>
      <div class="feed-controls">
        <select id="filterStream">
          <option value="">All streams</option>
        </select>
        <input type="text" id="filterSearch" placeholder="Search type, handler, or message ID..." oninput="applyFilters()">
      </div>
    </div>
    <!-- Messages tab content -->
    <div class="tab-content" id="messagesContent">
      <div class="new-messages-banner" id="newMessagesBanner" onclick="scrollToTopMessages()" style="display:none">
        &uarr; <span id="newMsgCount">0</span> new messages
      </div>
      <div class="feed-empty" id="messagesEmpty">Loading history...</div>
    </div>
    <!-- Events tab content (hidden by default) -->
    <div class="tab-content" id="eventsContent" style="display:none">
      <div class="feed-empty" id="eventsEmpty">Loading history...</div>
    </div>
  </div>

  <!-- Infrastructure -->
  <div class="card">
    <div class="card-header">Infrastructure</div>
    <div class="card-body">
      <div class="infra-grid" id="infraGrid">
        <div class="infra-item">
          <span class="status-dot disconnected" id="redisStatus"></span>
          <span class="label">Redis</span>
          <span class="value" id="redisInfo">Checking...</span>
        </div>
      </div>
    </div>
  </div>

</div>

<div class="new-events-badge" id="newEventsBadge" onclick="scrollToTop()">
  &#8595; New events
</div>

<script>
// --- State ---
let paused = false;
let connected = false;
let eventSource = null;
let pauseBuffer = [];
const MAX_ITEMS = 500;

// Current window for stats
let currentWindow = '5m';

// Current view tab: 'messages', 'events', 'errors'
let currentTab = 'messages';

// History / dedup
let historyLoaded = false;
const seenTraceKeys = new Set();
let sseConnectedAt = 0;

// All traces in memory for lifecycle lookup
const tracesByMessageId = new Map(); // message_id -> [{...}, ...]
let errorCount = 0;

// Message-centric data
const messageById = new Map();   // message_id -> { message_id, message_type, stream, domain, first_ts, stages: [], payload: null, hasError: false }
const messageOrder = [];         // message_ids in newest-first order

// Currently expanded message
let expandedMessageId = null;

// Batched rendering state
let pendingMessageUpdates = new Set();  // message_ids needing DOM update
let pendingEventItems = [];             // event data items to add to events tab
let rafScheduled = false;

// Scroll-aware state for messages tab
let userScrolledMessages = false;
let newMessageCount = 0;

// Real-time metrics state (SSE delta + server poll base)
let statsBase = null;           // Last /api/traces/stats response
let statsDelta = {};            // event_type -> count (SSE increments since last poll)
let latencyDeltaSum = 0;        // Sum of handler.completed duration_ms since last poll
let latencyDeltaCount = 0;      // Count of handler.completed events since last poll
let metricsRafScheduled = false;

const ERROR_EVENTS = new Set(['handler.failed', 'outbox.failed', 'message.dlq', 'message.nacked']);

// Known domains and streams for filter population
const knownDomains = new Set();
const knownStreams = new Set();

// Throughput tracking (per-second buckets for last 300s = 5 min)
const THROUGHPUT_SECONDS = 300;
const throughput = {
  published: new Array(THROUGHPUT_SECONDS).fill(0),
  processed: new Array(THROUGHPUT_SECONDS).fill(0),
  errors: new Array(THROUGHPUT_SECONDS).fill(0),
};
let currentSecond = { published: 0, processed: 0, errors: 0 };

// Event icons for events tab
const EVENT_ICONS = {
  'outbox.published': '\u2191',
  'outbox.failed': '\u2717',
  'handler.started': '\u25b6',
  'handler.completed': '\u2713',
  'handler.failed': '\u2717',
  'message.acked': '\u2713',
  'message.nacked': '\u21bb',
  'message.dlq': '\u26a0',
};

const EVENT_STATUS_CLASS = {
  'outbox.published': 'status-ok',
  'outbox.failed': 'status-error',
  'handler.started': 'status-ok',
  'handler.completed': 'status-ok',
  'handler.failed': 'status-error',
  'message.acked': 'status-ok',
  'message.nacked': 'status-retry',
  'message.dlq': 'status-error',
};

// Stage ordering for lifecycle bar
const STAGE_ORDER = {
  'outbox.published': 0,
  'handler.started': 1,
  'handler.completed': 2,
  'handler.failed': 2,
  'message.acked': 3,
  'message.nacked': 3,
  'message.dlq': 3,
  'outbox.failed': 1,
};

// Marker CSS class for each event type
const MARKER_CLASS = {
  'outbox.published': 'published',
  'handler.started': 'started',
  'handler.completed': 'completed',
  'handler.failed': 'failed',
  'message.acked': 'acked',
  'message.nacked': 'nacked',
  'message.dlq': 'dlq',
  'outbox.failed': 'failed',
};

// Short labels for lifecycle bar markers
const MARKER_ICON = {
  'outbox.published': '\u2191',
  'handler.started': '\u25b6',
  'handler.completed': '\u2713',
  'handler.failed': '\u2717',
  'message.acked': '\u2713',
  'message.nacked': '\u21bb',
  'message.dlq': '!',
  'outbox.failed': '\u2717',
};

// --- History Loading ---
async function loadHistory() {
  try {
    const res = await fetch('/api/traces?count=500');
    if (!res.ok) return;
    const data = await res.json();
    const traces = data.traces || [];

    if (traces.length === 0) {
      setEmptyMessage('No events in history. Connect engines to see message flow.');
      return;
    }

    // Remove empty messages
    clearEmptyMessages();

    // Process oldest-first for correct grouping
    const reversed = [...traces].reverse();
    for (const trace of reversed) {
      const key = trace.message_id + ':' + trace.event + ':' + (trace.handler || '');
      seenTraceKeys.add(key);
      trackTrace(trace);
      updateThroughputFromHistory(trace);
    }

    renderAllMessages();

    // Insert divider in events tab
    const eventsDiv = document.getElementById('eventsContent');
    const divider = document.createElement('div');
    divider.className = 'feed-divider';
    divider.id = 'historyDivider';
    divider.textContent = '--- live ---';
    eventsDiv.insertBefore(divider, eventsDiv.firstChild);

    // Render events tab
    const allTraces = [...traces]; // newest-first from API
    for (const trace of allTraces) {
      addEventFeedItem(trace, true);
    }

    historyLoaded = true;
    updateErrorBadge();
  } catch (e) {
    console.error('Failed to load history:', e);
    setEmptyMessage('Failed to load history. Waiting for live events...');
  }
}

function setEmptyMessage(msg) {
  const mEmpty = document.getElementById('messagesEmpty');
  if (mEmpty) mEmpty.textContent = msg;
  const eEmpty = document.getElementById('eventsEmpty');
  if (eEmpty) eEmpty.textContent = msg;
}

function clearEmptyMessages() {
  const mEmpty = document.getElementById('messagesEmpty');
  if (mEmpty) mEmpty.remove();
  const eEmpty = document.getElementById('eventsEmpty');
  if (eEmpty) eEmpty.remove();
}

function updateThroughputFromHistory(trace) {
  const ts = trace.timestamp ? new Date(trace.timestamp).getTime() : 0;
  if (!ts) return;

  const now = Date.now();
  const ageSeconds = Math.floor((now - ts) / 1000);
  const bucketIndex = THROUGHPUT_SECONDS - 1 - ageSeconds;
  if (bucketIndex < 0 || bucketIndex >= THROUGHPUT_SECONDS) return;

  if (trace.event === 'outbox.published') throughput.published[bucketIndex]++;
  if (trace.event === 'handler.completed') throughput.processed[bucketIndex]++;
  if (trace.event === 'handler.failed' || trace.event === 'message.dlq') throughput.errors[bucketIndex]++;
}

// --- In-Flight Computation ---
function computeInFlight() {
  let count = 0;
  for (const [id, msg] of messageById) {
    const stages = msg.stages;
    const isPublished = stages.some(s => s.event === 'outbox.published');
    if (!isPublished) continue;

    const startedHandlers = new Set();
    const doneHandlers = new Set();
    for (const s of stages) {
      if (s.event === 'handler.started') startedHandlers.add(s.handler);
      if (s.event === 'handler.completed' || s.event === 'handler.failed')
        doneHandlers.add(s.handler);
    }

    // In flight if: published and (no handlers started OR some started but not done)
    if (startedHandlers.size === 0 || startedHandlers.size > doneHandlers.size) {
      count++;
    }
  }
  return count;
}

// --- Stats Loading ---
async function loadStats() {
  try {
    const res = await fetch('/api/traces/stats?window=' + currentWindow);
    if (!res.ok) return;
    const data = await res.json();

    // Store server response as base, reset SSE deltas
    statsBase = data;
    statsDelta = {};
    latencyDeltaSum = 0;
    latencyDeltaCount = 0;

    refreshMetrics();
  } catch (e) {
    console.error('Failed to load stats:', e);
  }
}

// --- Unified Metrics Refresh (base + SSE deltas) ---
function refreshMetrics() {
  if (!statsBase) return;

  // Merge base counts with SSE delta increments
  const counts = { ...(statsBase.counts || {}) };
  for (const [evt, n] of Object.entries(statsDelta)) {
    counts[evt] = (counts[evt] || 0) + n;
  }

  const total = Object.values(counts).reduce((a, b) => a + b, 0);
  const windowMinutes = { '5m': 5, '15m': 15, '1h': 60, '24h': 1440, '7d': 10080 }[currentWindow] || 5;

  // Throughput
  const perMin = total > 0 ? Math.round(total / windowMinutes) : 0;
  document.getElementById('metricThroughput').textContent = perMin + '/min';

  // Error rate
  const errCount = (counts['handler.failed'] || 0) + (counts['outbox.failed'] || 0) + (counts['message.dlq'] || 0);
  const errorRate = total > 0 ? Math.round(errCount / total * 10000) / 100 : 0;
  const errorEl = document.getElementById('metricErrorRate');
  errorEl.textContent = errorRate + '%';
  errorEl.className = 'metric-value ' + (errorRate === 0 ? 'good' : errorRate < 5 ? 'warn' : 'bad');

  // Avg latency (blend base + SSE delta)
  const baseCompleted = (statsBase.counts || {})['handler.completed'] || 0;
  const baseLatencySum = (statsBase.avg_latency_ms || 0) * baseCompleted;
  const totalLatencySum = baseLatencySum + latencyDeltaSum;
  const totalLatencyCount = baseCompleted + latencyDeltaCount;
  const avgLatency = totalLatencyCount > 0 ? Math.round(totalLatencySum / totalLatencyCount * 100) / 100 : 0;
  const latencyEl = document.getElementById('metricLatency');
  latencyEl.textContent = avgLatency > 0 ? avgLatency + 'ms' : '--';

  // In Flight
  const inFlight = computeInFlight();
  const inFlightEl = document.getElementById('metricInFlight');
  inFlightEl.textContent = inFlight;
  inFlightEl.className = 'metric-value ' + (inFlight === 0 ? 'good' : inFlight <= 10 ? 'warn' : 'bad');

  // Pipeline counts
  const published = counts['outbox.published'] || 0;
  const handling = Math.max(0, (counts['handler.started'] || 0) - (counts['handler.completed'] || 0) - (counts['handler.failed'] || 0));
  const done = counts['handler.completed'] || 0;
  const failed = errCount;

  document.getElementById('pipePublished').textContent = published;
  document.getElementById('pipeHandling').textContent = handling;
  document.getElementById('pipeDone').textContent = done;
  document.getElementById('pipeFailed').textContent = failed;

  // Rate labels
  document.getElementById('ratePublishedPipe').textContent = published > 0 ? '~' + Math.round(published / windowMinutes) + '/min' : '';
  document.getElementById('rateHandling').textContent = handling > 0 ? '~' + Math.round(handling / windowMinutes) + '/min' : '';
  document.getElementById('rateDone').textContent = done > 0 ? '~' + Math.round(done / windowMinutes) + '/min' : '';
  document.getElementById('rateFailed').textContent = failed > 0 ? '~' + Math.round(failed / windowMinutes) + '/min' : '';
}

function scheduleMetricsRefresh() {
  if (!metricsRafScheduled) {
    metricsRafScheduled = true;
    requestAnimationFrame(() => {
      metricsRafScheduled = false;
      refreshMetrics();
    });
  }
}

function setWindow(w) {
  currentWindow = w;
  document.querySelectorAll('.window-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.window === w);
  });
  loadStats();
}

// --- Trace Tracking ---
function trackTrace(data) {
  if (!data.message_id) return;

  // Track in tracesByMessageId
  if (!tracesByMessageId.has(data.message_id)) {
    tracesByMessageId.set(data.message_id, []);
  }
  tracesByMessageId.get(data.message_id).push(data);

  if (ERROR_EVENTS.has(data.event)) {
    errorCount++;
  }

  // Track in message-centric data
  if (!messageById.has(data.message_id)) {
    const entry = {
      message_id: data.message_id,
      message_type: data.message_type || 'Unknown',
      stream: data.stream || '',
      domain: data.domain || '',
      first_ts: data.timestamp || new Date().toISOString(),
      stages: [],
      payload: null,
      hasError: false,
    };
    messageById.set(data.message_id, entry);
    messageOrder.unshift(data.message_id);
  }

  const msg = messageById.get(data.message_id);
  msg.stages.push(data);

  if (data.payload) {
    msg.payload = data.payload;
  }
  if (ERROR_EVENTS.has(data.event)) {
    msg.hasError = true;
  }

  // Track domains and streams for filters
  if (data.domain && !knownDomains.has(data.domain)) {
    knownDomains.add(data.domain);
    updateDomainFilter();
  }
  if (data.stream && !knownStreams.has(data.stream)) {
    knownStreams.add(data.stream);
    updateStreamFilter();
  }
}

// --- SSE Connection ---
function connectSSE() {
  const params = new URLSearchParams();
  const domainFilter = document.getElementById('filterDomain').value;
  if (domainFilter) params.set('domain', domainFilter);

  const url = '/stream' + (params.toString() ? '?' + params.toString() : '');
  eventSource = new EventSource(url);

  eventSource.addEventListener('trace', (e) => {
    try {
      const data = JSON.parse(e.data);
      handleTraceEvent(data);
    } catch (err) {
      console.error('Parse error:', err);
    }
  });

  eventSource.addEventListener('error', (e) => {
    try {
      const data = JSON.parse(e.data);
      console.error('Observatory error:', data.error);
    } catch {}
  });

  eventSource.onopen = () => {
    connected = true;
    sseConnectedAt = Date.now();
    document.getElementById('statusDot').className = 'status-dot connected';
    setTimeout(() => seenTraceKeys.clear(), 5000);
  };

  eventSource.onerror = () => {
    connected = false;
    document.getElementById('statusDot').className = 'status-dot disconnected';
  };
}

function handleTraceEvent(data) {
  // Dedup
  if (seenTraceKeys.size > 0) {
    const key = data.message_id + ':' + data.event + ':' + (data.handler || '');
    if (seenTraceKeys.has(key)) return;
  }

  trackTrace(data);
  updateThroughput(data);
  updateErrorBadge();

  // Increment SSE counters for real-time metrics
  statsDelta[data.event] = (statsDelta[data.event] || 0) + 1;
  if (data.event === 'handler.completed' && data.duration_ms != null) {
    latencyDeltaSum += parseFloat(data.duration_ms);
    latencyDeltaCount++;
  }
  scheduleMetricsRefresh();

  if (paused) {
    pauseBuffer.push(data);
    return;
  }

  // Schedule batched DOM updates instead of immediate rendering
  scheduleUpdate(data.message_id, data);
}

// --- Batched Rendering ---
function scheduleUpdate(messageId, eventData) {
  pendingMessageUpdates.add(messageId);
  if (eventData) pendingEventItems.push(eventData);

  if (!rafScheduled) {
    rafScheduled = true;
    requestAnimationFrame(flushUpdates);
  }
}

function flushUpdates() {
  rafScheduled = false;

  // Flush message row updates
  for (const msgId of pendingMessageUpdates) {
    updateMessageRow(msgId, false);

    // Update expanded detail if this message is expanded
    if (msgId === expandedMessageId) {
      renderExpandedDetail(msgId);
    }
  }
  pendingMessageUpdates.clear();

  // Flush event feed items
  for (const data of pendingEventItems) {
    addEventFeedItem(data, false);
  }
  pendingEventItems = [];
}

// --- Scroll-Aware Updates ---
function initScrollListener() {
  const container = document.getElementById('messagesContent');
  container.addEventListener('scroll', () => {
    const wasScrolled = userScrolledMessages;
    userScrolledMessages = container.scrollTop > 60;
    if (!userScrolledMessages && wasScrolled) {
      hideNewMessagesBanner();
    }
  });
}

function showNewMessagesBanner() {
  const banner = document.getElementById('newMessagesBanner');
  const countEl = document.getElementById('newMsgCount');
  if (banner && countEl) {
    countEl.textContent = newMessageCount;
    banner.style.display = '';
  }
}

function hideNewMessagesBanner() {
  const banner = document.getElementById('newMessagesBanner');
  if (banner) banner.style.display = 'none';
  newMessageCount = 0;
}

function scrollToTopMessages() {
  const container = document.getElementById('messagesContent');
  container.scrollTop = 0;
  userScrolledMessages = false;
  hideNewMessagesBanner();
}

// --- Throughput ---
function updateThroughput(data) {
  if (data.event === 'outbox.published') currentSecond.published++;
  if (data.event === 'handler.completed') currentSecond.processed++;
  if (data.event === 'handler.failed' || data.event === 'message.dlq') currentSecond.errors++;
}

function tickThroughput() {
  throughput.published.push(currentSecond.published);
  throughput.published.shift();
  throughput.processed.push(currentSecond.processed);
  throughput.processed.shift();
  throughput.errors.push(currentSecond.errors);
  throughput.errors.shift();

  document.getElementById('ratePublished').textContent = currentSecond.published + '/s';
  document.getElementById('rateProcessed').textContent = currentSecond.processed + '/s';
  document.getElementById('rateErrors').textContent = currentSecond.errors + '/s';

  currentSecond = { published: 0, processed: 0, errors: 0 };
  drawSparkline();
}

function drawSparkline() {
  const canvas = document.getElementById('sparkline');
  const ctx = canvas.getContext('2d');
  const w = canvas.width;
  const h = canvas.height;

  ctx.clearRect(0, 0, w, h);

  const maxVal = Math.max(1, ...throughput.published, ...throughput.processed);
  const barWidth = w / THROUGHPUT_SECONDS;

  ctx.fillStyle = '#457B9D44';
  for (let i = 0; i < THROUGHPUT_SECONDS; i++) {
    const barH = (throughput.published[i] / maxVal) * h;
    ctx.fillRect(i * barWidth, h - barH, barWidth - 0.5, barH);
  }

  ctx.strokeStyle = '#2A9D8F';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  for (let i = 0; i < THROUGHPUT_SECONDS; i++) {
    const x = i * barWidth + barWidth / 2;
    const y = h - (throughput.processed[i] / maxVal) * h;
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.stroke();

  ctx.fillStyle = '#E76F51';
  for (let i = 0; i < THROUGHPUT_SECONDS; i++) {
    if (throughput.errors[i] > 0) {
      const x = i * barWidth + barWidth / 2;
      const y = h - (throughput.errors[i] / maxVal) * h;
      ctx.beginPath();
      ctx.arc(x, y, 2, 0, Math.PI * 2);
      ctx.fill();
    }
  }
}

// --- Messages Tab ---
function renderAllMessages() {
  const container = document.getElementById('messagesContent');
  const empty = container.querySelector('.feed-empty');
  if (empty) empty.remove();

  // Clear and rebuild — preserve the banner
  container.innerHTML = '<div class="new-messages-banner" id="newMessagesBanner" onclick="scrollToTopMessages()" style="display:none">&uarr; <span id="newMsgCount">0</span> new messages</div>';

  // Render newest-first
  for (const msgId of messageOrder) {
    const row = buildMessageRow(msgId);
    if (row) container.appendChild(row);
  }

  // Trim excess rows
  const rows = container.querySelectorAll('.msg-row');
  for (let i = MAX_ITEMS; i < rows.length; i++) {
    rows[i].remove();
  }
}

function updateMessageRow(messageId, isHistory) {
  const container = document.getElementById('messagesContent');
  const empty = container.querySelector('.feed-empty');
  if (empty) empty.remove();

  // Determine the first real child (skip the sticky banner)
  const banner = document.getElementById('newMessagesBanner');
  const firstChild = banner ? banner.nextElementSibling : container.firstChild;

  // Find existing row
  const existing = container.querySelector(`[data-msg-id="${messageId}"]`);

  if (existing) {
    // Update lifecycle bar in place
    const barEl = existing.querySelector('.lifecycle-bar');
    if (barEl) {
      barEl.innerHTML = buildLifecycleBarHTML(messageId);
    }
    // Move to top if live AND user hasn't scrolled away
    if (!isHistory && !userScrolledMessages) {
      if (firstChild) {
        container.insertBefore(existing, firstChild);
      } else {
        container.appendChild(existing);
      }
    } else if (!isHistory && userScrolledMessages) {
      // User is scrolled — don't reorder, just show banner
      newMessageCount++;
      showNewMessagesBanner();
    }
  } else {
    const row = buildMessageRow(messageId);
    if (row) {
      if (!isHistory && !userScrolledMessages) {
        row.classList.add('new');
        if (firstChild) {
          container.insertBefore(row, firstChild);
        } else {
          container.appendChild(row);
        }
        setTimeout(() => row.classList.remove('new'), 300);
      } else if (!isHistory && userScrolledMessages) {
        // User is scrolled — insert at top but don't scroll
        if (firstChild) {
          container.insertBefore(row, firstChild);
        } else {
          container.appendChild(row);
        }
        newMessageCount++;
        showNewMessagesBanner();
      } else {
        // History — append
        container.appendChild(row);
      }
    }
  }

  // Apply filter
  applyFilters();

  // Trim excess rows (keep banner)
  const rows = container.querySelectorAll('.msg-row');
  if (rows.length > MAX_ITEMS) {
    for (let i = MAX_ITEMS; i < rows.length; i++) {
      rows[i].remove();
    }
  }
}

function buildMessageRow(messageId) {
  const msg = messageById.get(messageId);
  if (!msg) return null;

  const row = document.createElement('div');
  row.className = 'msg-row';
  row.setAttribute('data-msg-id', messageId);
  row.setAttribute('data-stream', msg.stream);
  row.setAttribute('data-type', msg.message_type);
  row.setAttribute('data-has-error', msg.hasError ? '1' : '0');

  const ts = msg.first_ts ? new Date(msg.first_ts) : new Date();
  const timeStr = ts.toLocaleTimeString('en-US', { hour12: false, fractionalSecondDigits: 3 });

  // Summary line
  const summary = document.createElement('div');
  summary.className = 'msg-summary';

  // Duration: find completed stage
  let durationStr = '';
  for (const s of msg.stages) {
    if (s.duration_ms != null) {
      durationStr = s.duration_ms.toFixed(1) + 'ms';
      break;
    }
  }

  summary.innerHTML = `
    <span class="msg-time">${timeStr}</span>
    <div class="msg-info">
      <span class="msg-type">${escapeHtml(msg.message_type)}</span>
      <span class="msg-stream">${escapeHtml(msg.stream)}</span>
      <span class="msg-id">${escapeHtml(messageId)}</span>
    </div>
    <span style="font-family:var(--font-code);font-size:12px;color:var(--text-muted)">${durationStr}</span>
  `;

  row.appendChild(summary);

  // Lifecycle bar
  const bar = document.createElement('div');
  bar.className = 'lifecycle-bar';
  bar.innerHTML = buildLifecycleBarHTML(messageId);
  row.appendChild(bar);

  // Detail panel (hidden by default)
  const detail = document.createElement('div');
  detail.className = 'msg-detail';
  row.appendChild(detail);

  // Click handler
  summary.addEventListener('click', () => toggleMessageExpand(messageId, row));
  bar.addEventListener('click', () => toggleMessageExpand(messageId, row));

  return row;
}

function buildLifecycleBarHTML(messageId) {
  const msg = messageById.get(messageId);
  if (!msg) return '';

  // Sort stages chronologically
  const sorted = [...msg.stages].sort((a, b) => {
    const ta = a.timestamp ? new Date(a.timestamp).getTime() : 0;
    const tb = b.timestamp ? new Date(b.timestamp).getTime() : 0;
    return ta - tb;
  });

  // Separate published (no handler) from handler stages
  const publishedStages = sorted.filter(s => !s.handler || s.event === 'outbox.published');
  const handlerStages = sorted.filter(s => s.handler && s.event !== 'outbox.published');

  // Group handler stages by handler name (preserving order)
  const handlerGroups = new Map();
  for (const s of handlerStages) {
    const h = s.handler;
    if (!handlerGroups.has(h)) handlerGroups.set(h, []);
    handlerGroups.get(h).push(s);
  }

  const isMultiHandler = handlerGroups.size > 1;
  let html = '';

  // Render published marker(s)
  for (let i = 0; i < publishedStages.length; i++) {
    const stage = publishedStages[i];
    const cls = MARKER_CLASS[stage.event] || 'published';
    const icon = MARKER_ICON[stage.event] || '?';
    html += `<div class="lbar-marker ${cls}" title="${escapeHtml(stage.event)}">${icon}</div>`;
  }

  if (isMultiHandler) {
    // Multi-handler: compact segments per handler
    let first = true;
    for (const [handlerName, stages] of handlerGroups) {
      html += `<div class="lbar-line ok"></div>`;
      html += `<div class="lbar-handler-segment">`;
      // Truncated handler name
      const shortName = handlerName.length > 18 ? handlerName.substring(0, 16) + '..' : handlerName;
      html += `<span class="lbar-handler-name" title="${escapeHtml(handlerName)}">${escapeHtml(shortName)}</span>`;
      for (let i = 0; i < stages.length; i++) {
        const stage = stages[i];
        const cls = MARKER_CLASS[stage.event] || 'published';
        const icon = MARKER_ICON[stage.event] || '?';
        html += `<div class="lbar-marker ${cls}" title="${escapeHtml(stage.event)}">${icon}</div>`;
      }
      // Duration after segment if handler.completed present
      const completed = stages.find(s => s.event === 'handler.completed' && s.duration_ms != null);
      if (completed) {
        html += `<span class="lbar-label">${completed.duration_ms.toFixed(1)}ms</span>`;
      }
      // Error indicator
      const failed = stages.find(s => s.event === 'handler.failed');
      if (failed && failed.error) {
        html += `<span class="lbar-label" style="color:var(--accent)">err</span>`;
      }
      // In-progress indicator
      const lastStage = stages[stages.length - 1];
      if (lastStage.event === 'handler.started') {
        html += `<span class="lbar-in-progress">...</span>`;
      }
      html += `</div>`;
    }
  } else {
    // Single handler (or no handler): flat layout as before
    for (let i = 0; i < handlerStages.length; i++) {
      const stage = handlerStages[i];
      const cls = MARKER_CLASS[stage.event] || 'published';
      const icon = MARKER_ICON[stage.event] || '?';

      html += `<div class="lbar-line ${ERROR_EVENTS.has(stage.event) ? 'error' : 'ok'}"></div>`;
      html += `<div class="lbar-marker ${cls}" title="${escapeHtml(stage.event)}">${icon}</div>`;

      if (stage.event === 'handler.completed' && stage.duration_ms != null) {
        html += `<span class="lbar-label">${stage.duration_ms.toFixed(1)}ms</span>`;
      }
      if (stage.event === 'handler.failed' && stage.error) {
        html += `<span class="lbar-label" style="color:var(--accent)">${escapeHtml(stage.error.substring(0, 40))}</span>`;
      }
    }

    // In-progress indicator for single handler
    if (handlerStages.length > 0) {
      const last = handlerStages[handlerStages.length - 1];
      if (last.event === 'handler.started') {
        html += `<div class="lbar-line pending"></div>`;
        html += `<span class="lbar-in-progress">...</span>`;
      }
    }
  }

  return html;
}

function toggleMessageExpand(messageId, row) {
  if (expandedMessageId === messageId) {
    // Collapse
    row.classList.remove('expanded');
    expandedMessageId = null;
    return;
  }

  // Collapse previous
  const prev = document.querySelector('.msg-row.expanded');
  if (prev) prev.classList.remove('expanded');

  expandedMessageId = messageId;
  row.classList.add('expanded');
  renderExpandedDetail(messageId);
}

function renderExpandedDetail(messageId) {
  const row = document.querySelector(`[data-msg-id="${messageId}"]`);
  if (!row) return;
  const detailEl = row.querySelector('.msg-detail');
  if (!detailEl) return;

  const msg = messageById.get(messageId);
  if (!msg) return;

  const sorted = [...msg.stages].sort((a, b) => {
    const ta = a.timestamp ? new Date(a.timestamp).getTime() : 0;
    const tb = b.timestamp ? new Date(b.timestamp).getTime() : 0;
    return ta - tb;
  });

  // Separate published (no handler) from handler stages
  const publishedStages = sorted.filter(s => !s.handler || s.event === 'outbox.published');
  const handlerStages = sorted.filter(s => s.handler && s.event !== 'outbox.published');

  // Group handler stages by handler name (preserving chronological order)
  const handlerGroups = new Map();
  for (const s of handlerStages) {
    const h = s.handler;
    if (!handlerGroups.has(h)) handlerGroups.set(h, []);
    handlerGroups.get(h).push(s);
  }

  const isMultiHandler = handlerGroups.size > 1;

  let html = '';

  // Two-column layout: timeline left, payload/meta right
  html += '<div class="detail-columns">';

  // === LEFT COLUMN: Timeline ===
  html += '<div class="detail-col-left">';
  html += '<div class="detail-section">';
  html += '<div class="detail-section-title">Timeline</div>';
  html += '<div class="detail-timeline">';

  if (isMultiHandler) {
    // Multi-handler: one section per handler
    for (const [handlerName, stages] of handlerGroups) {
      html += '<div class="dtl-handler-group">';
      html += `<div class="dtl-handler-label">${escapeHtml(handlerName)}</div>`;
      html += '<div class="dtl-handler-stages">';

      for (let i = 0; i < stages.length; i++) {
        const stage = stages[i];
        const cls = MARKER_CLASS[stage.event] || 'published';
        const icon = MARKER_ICON[stage.event] || '?';
        const ts = stage.timestamp ? new Date(stage.timestamp) : new Date();
        const timeStr = ts.toLocaleTimeString('en-US', { hour12: false, fractionalSecondDigits: 3 });

        if (i > 0) {
          const lineClass = ERROR_EVENTS.has(stage.event) ? 'error' : 'ok';
          if (stage.duration_ms != null) {
            html += `<span class="dtl-duration">${stage.duration_ms.toFixed(1)}ms</span>`;
          }
          html += `<div class="dtl-line ${lineClass}"></div>`;
        }

        html += `<div class="dtl-stage">`;
        html += `<div class="dtl-marker ${cls}">${icon}</div>`;
        html += `<div class="dtl-event-name">${escapeHtml(stage.event.split('.')[1] || stage.event)}</div>`;
        html += `<div class="dtl-time">${timeStr}</div>`;
        html += `</div>`;
      }

      html += '</div></div>';
    }
  } else {
    // Single handler or no handler: flat layout
    if (handlerStages.length > 0) {
      const handlerName = handlerStages[0].handler;
      html += '<div class="dtl-handler-group">';
      if (handlerName) {
        html += `<div class="dtl-handler-label">${escapeHtml(handlerName)}</div>`;
      }
      html += '<div class="dtl-handler-stages">';

      for (let i = 0; i < handlerStages.length; i++) {
        const stage = handlerStages[i];
        const cls = MARKER_CLASS[stage.event] || 'published';
        const icon = MARKER_ICON[stage.event] || '?';
        const ts = stage.timestamp ? new Date(stage.timestamp) : new Date();
        const timeStr = ts.toLocaleTimeString('en-US', { hour12: false, fractionalSecondDigits: 3 });

        if (i > 0) {
          const lineClass = ERROR_EVENTS.has(stage.event) ? 'error' : 'ok';
          if (stage.duration_ms != null) {
            html += `<span class="dtl-duration">${stage.duration_ms.toFixed(1)}ms</span>`;
          }
          html += `<div class="dtl-line ${lineClass}"></div>`;
        }

        html += `<div class="dtl-stage">`;
        html += `<div class="dtl-marker ${cls}">${icon}</div>`;
        html += `<div class="dtl-event-name">${escapeHtml(stage.event.split('.')[1] || stage.event)}</div>`;
        html += `<div class="dtl-time">${timeStr}</div>`;
        html += `</div>`;
      }

      html += '</div></div>';
    }
  }

  html += '</div></div>';

  // Error (if any) — shown below timeline in left column
  const errorStages = sorted.filter(s => s.error);
  if (errorStages.length > 0) {
    html += '<div class="detail-section">';
    html += '<div class="detail-section-title">Error</div>';
    for (const es of errorStages) {
      html += '<div class="error-detail-box">';
      if (es.handler) html += '<strong>' + escapeHtml(es.handler) + '</strong>: ';
      html += escapeHtml(es.error);
      html += '</div>';
    }
    html += '</div>';
  }

  html += '</div>'; // end detail-col-left

  // === RIGHT COLUMN: Message ID + Payload ===
  html += '<div class="detail-col-right">';

  // Message ID
  html += '<div class="detail-section">';
  html += '<div class="detail-section-title">Message ID <button class="copy-btn" onclick="copyText(\'' + escapeHtml(messageId) + '\', this)">Copy</button></div>';
  html += '<div style="font-family:var(--font-code);font-size:11px;color:var(--text-muted);word-break:break-all">' + escapeHtml(messageId) + '</div>';
  html += '</div>';

  // Payload
  html += '<div class="detail-section">';
  const payloadJson = msg.payload ? JSON.stringify(msg.payload, null, 2) : null;
  if (payloadJson) {
    html += '<div class="detail-section-title">Payload <button class="copy-btn" onclick="copyPayload(\'' + escapeHtml(messageId) + '\', this)">Copy</button></div>';
    html += '<div class="payload-container"><div class="payload-block">' + escapeHtml(payloadJson) + '</div></div>';
  } else {
    html += '<div class="detail-section-title">Payload</div>';
    html += '<div class="payload-empty">Payload not captured for this message</div>';
  }
  html += '</div>';

  html += '</div>'; // end detail-col-right
  html += '</div>'; // end detail-columns

  detailEl.innerHTML = html;
}

// --- Events Tab ---
function addEventFeedItem(data, isHistory) {
  const container = document.getElementById('eventsContent');
  const empty = container.querySelector('.feed-empty');
  if (empty) empty.remove();

  const item = document.createElement('div');
  const statusClass = EVENT_STATUS_CLASS[data.event] || '';
  item.className = `feed-item ${statusClass}` + (isHistory ? '' : ' new');
  item.setAttribute('data-event', data.event || '');
  item.setAttribute('data-stream', data.stream || '');
  item.setAttribute('data-type', data.message_type || '');
  item.setAttribute('data-message-id', data.message_id || '');

  const ts = data.timestamp ? new Date(data.timestamp) : new Date();
  const timeStr = ts.toLocaleTimeString('en-US', { hour12: false, fractionalSecondDigits: 3 });

  let detail = data.stream || '';
  if (data.handler) detail += ' \u2192 ' + data.handler;

  let rightCol = '';
  if (data.duration_ms != null) {
    rightCol = data.duration_ms.toFixed(1) + 'ms';
  }
  if (data.error) {
    rightCol = '<span class="error-text">' + escapeHtml(data.error.substring(0, 80)) + '</span>';
  }
  if (data.metadata && data.metadata.retry_count) {
    rightCol += ' <span style="color:var(--warning)">[retry ' + data.metadata.retry_count + ']</span>';
  }

  item.innerHTML = `
    <span class="timestamp">${timeStr}</span>
    <span class="icon">${EVENT_ICONS[data.event] || '?'}</span>
    <span class="event-type">${escapeHtml(data.event || '')}</span>
    <div class="message-info">
      <span class="message-type">${escapeHtml(data.message_type || '')}</span>
      <span class="message-detail">${escapeHtml(detail)}</span>
    </div>
    <span class="duration">${rightCol}</span>
  `;

  // Click to expand in messages tab
  item.addEventListener('click', () => {
    setViewTab('messages');
    // Find and expand the message
    const msgRow = document.querySelector(`[data-msg-id="${data.message_id}"]`);
    if (msgRow) {
      toggleMessageExpand(data.message_id, msgRow);
      msgRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
  });

  const divider = document.getElementById('historyDivider');
  if (isHistory && divider) {
    // Insert after divider for history items
    if (divider.nextSibling) {
      container.insertBefore(item, divider.nextSibling);
    } else {
      container.appendChild(item);
    }
  } else {
    container.insertBefore(item, container.firstChild);
  }

  // Trim
  const allItems = container.querySelectorAll('.feed-item');
  if (allItems.length > MAX_ITEMS) {
    container.removeChild(allItems[allItems.length - 1]);
  }

  if (!isHistory) {
    setTimeout(() => item.classList.remove('new'), 300);
  }
}

// --- View Tabs ---
function setViewTab(tab) {
  currentTab = tab;
  document.getElementById('tabMessages').classList.toggle('active', tab === 'messages');
  document.getElementById('tabEvents').classList.toggle('active', tab === 'events');
  document.getElementById('tabErrors').classList.toggle('active', tab === 'errors');

  document.getElementById('messagesContent').style.display = (tab === 'messages' || tab === 'errors') ? '' : 'none';
  document.getElementById('eventsContent').style.display = tab === 'events' ? '' : 'none';

  applyFilters();
}

function updateErrorBadge() {
  const badge = document.getElementById('errorBadge');
  if (errorCount > 0) {
    badge.textContent = errorCount > 99 ? '99+' : errorCount;
    badge.style.display = 'inline';
  } else {
    badge.style.display = 'none';
  }
}

// --- Filters ---
function matchesMessageFilters(msg) {
  const streamFilter = document.getElementById('filterStream').value;
  const searchFilter = document.getElementById('filterSearch').value.toLowerCase();

  if (currentTab === 'errors' && !msg.hasError) return false;
  if (streamFilter && msg.stream !== streamFilter) return false;
  if (searchFilter) {
    const searchable = (msg.message_type || '') + ' ' + (msg.stream || '') + ' ' + (msg.message_id || '') + ' ' +
      msg.stages.map(s => s.handler || '').join(' ');
    if (!searchable.toLowerCase().includes(searchFilter)) return false;
  }
  return true;
}

function applyFilters() {
  // Messages tab
  const msgContainer = document.getElementById('messagesContent');
  msgContainer.querySelectorAll('.msg-row').forEach(row => {
    const msgId = row.getAttribute('data-msg-id');
    const msg = messageById.get(msgId);
    if (msg) {
      row.style.display = matchesMessageFilters(msg) ? '' : 'none';
    }
  });

  // Events tab
  const evtContainer = document.getElementById('eventsContent');
  const streamFilter = document.getElementById('filterStream').value;
  const searchFilter = document.getElementById('filterSearch').value.toLowerCase();
  evtContainer.querySelectorAll('.feed-item').forEach(item => {
    const data = {
      stream: item.getAttribute('data-stream'),
      event: item.getAttribute('data-event'),
      message_type: item.getAttribute('data-type'),
      message_id: item.getAttribute('data-message-id'),
    };
    let show = true;
    if (streamFilter && data.stream !== streamFilter) show = false;
    if (searchFilter) {
      const searchable = (data.message_type || '') + ' ' + (data.stream || '') + ' ' + (data.message_id || '');
      if (!searchable.toLowerCase().includes(searchFilter)) show = false;
    }
    item.style.display = show ? '' : 'none';
  });
}

// --- Search by message_id ---
async function searchMessageById(query) {
  if (query.length < 8) return; // Too short for a UUID fragment

  // Check if it looks like a UUID pattern
  if (!/^[0-9a-f-]{8,}$/i.test(query)) return;

  // First check in-memory
  if (messageById.has(query)) return;

  // Fetch from server
  try {
    const res = await fetch('/api/traces?message_id=' + encodeURIComponent(query));
    if (!res.ok) return;
    const data = await res.json();
    if (!data.traces || data.traces.length === 0) return;

    // Process traces
    const reversed = [...data.traces].reverse();
    for (const trace of reversed) {
      trackTrace(trace);
    }
    updateMessageRow(query, true);
  } catch (e) {
    console.error('Search failed:', e);
  }
}

function scrollToTop() {
  const container = currentTab === 'events'
    ? document.getElementById('eventsContent')
    : document.getElementById('messagesContent');
  container.scrollTop = 0;
  document.getElementById('newEventsBadge').style.display = 'none';
}

function updateDomainFilter() {
  const select = document.getElementById('filterDomain');
  const current = select.value;
  select.innerHTML = '<option value="">All domains</option>';
  knownDomains.forEach(d => {
    const opt = document.createElement('option');
    opt.value = d;
    opt.textContent = d;
    select.appendChild(opt);
  });
  select.value = current;
}

function updateStreamFilter() {
  const select = document.getElementById('filterStream');
  const current = select.value;
  select.innerHTML = '<option value="">All streams</option>';
  knownStreams.forEach(s => {
    const opt = document.createElement('option');
    opt.value = s;
    opt.textContent = s;
    select.appendChild(opt);
  });
  select.value = current;
}

// --- Pause ---
function togglePause() {
  paused = !paused;
  const btn = document.getElementById('pauseBtn');
  if (paused) {
    btn.textContent = '\u25b6 Resume';
    btn.classList.add('active');
  } else {
    btn.textContent = '\u23f8 Pause';
    btn.classList.remove('active');
    // Batch resume: schedule all buffered updates
    for (const data of pauseBuffer) {
      scheduleUpdate(data.message_id, data);
    }
    pauseBuffer = [];
  }
}

// --- Reset ---
async function resetDashboard() {
  if (!confirm('Clear all trace history and reset counters?')) return;

  try {
    await fetch('/api/traces', { method: 'DELETE' });
  } catch (e) {
    console.error('Failed to clear trace stream:', e);
  }

  // Clear client-side state
  tracesByMessageId.clear();
  messageById.clear();
  messageOrder.length = 0;
  errorCount = 0;
  expandedMessageId = null;
  seenTraceKeys.clear();
  pendingMessageUpdates.clear();
  pendingEventItems = [];
  userScrolledMessages = false;
  newMessageCount = 0;
  statsBase = null;
  statsDelta = {};
  latencyDeltaSum = 0;
  latencyDeltaCount = 0;

  throughput.published.fill(0);
  throughput.processed.fill(0);
  throughput.errors.fill(0);
  currentSecond = { published: 0, processed: 0, errors: 0 };

  document.getElementById('messagesContent').innerHTML = '<div class="new-messages-banner" id="newMessagesBanner" onclick="scrollToTopMessages()" style="display:none">&uarr; <span id="newMsgCount">0</span> new messages</div><div class="feed-empty">History cleared. Waiting for new events...</div>';
  document.getElementById('eventsContent').innerHTML = '<div class="feed-empty">History cleared. Waiting for new events...</div>';

  updateErrorBadge();
  drawSparkline();
  await loadStats();
  await pollInfrastructure();
}

// --- Copy helpers ---
function copyText(text, btn) {
  navigator.clipboard.writeText(text).then(() => {
    btn.textContent = '\u2713 Copied';
    btn.classList.add('copied');
    setTimeout(() => {
      btn.textContent = 'Copy';
      btn.classList.remove('copied');
    }, 2000);
  });
}

function copyPayload(messageId, btn) {
  const msg = messageById.get(messageId);
  if (msg && msg.payload) {
    const text = JSON.stringify(msg.payload, null, 2);
    copyText(text, btn);
  }
}

// --- Infrastructure polling ---
async function pollInfrastructure() {
  try {
    const res = await fetch('/api/health');
    const data = await res.json();
    const redis = data.infrastructure?.redis || {};

    document.getElementById('infraGrid').innerHTML = `
      <div class="infra-item">
        <span class="status-dot ${redis.healthy ? 'connected' : 'disconnected'}"></span>
        <span class="label">Redis</span>
        <span class="value">${redis.healthy ? 'Healthy' : 'Down'}</span>
      </div>
      <div class="infra-item">
        <span class="label">Memory:</span>
        <span class="value">${redis.memory || '?'}</span>
      </div>
      <div class="infra-item">
        <span class="label">Ops/s:</span>
        <span class="value">${redis.ops_per_sec ?? '?'}</span>
      </div>
      <div class="infra-item">
        <span class="label">Clients:</span>
        <span class="value">${redis.connected_clients ?? '?'}</span>
      </div>
      <div class="infra-item">
        <span class="label">Uptime:</span>
        <span class="value">${formatUptime(redis.uptime_seconds)}</span>
      </div>
    `;

  } catch (e) {
    console.error('Infrastructure poll failed:', e);
  }
}

// --- Utils ---
function escapeHtml(str) {
  const div = document.createElement('div');
  div.textContent = str;
  return div.innerHTML;
}

function formatUptime(seconds) {
  if (!seconds) return '?';
  const d = Math.floor(seconds / 86400);
  const h = Math.floor((seconds % 86400) / 3600);
  const m = Math.floor((seconds % 3600) / 60);
  if (d > 0) return d + 'd ' + h + 'h';
  if (h > 0) return h + 'h ' + m + 'm';
  return m + 'm';
}

// --- Filter change handlers ---
document.getElementById('filterDomain').addEventListener('change', () => {
  if (eventSource) eventSource.close();
  connectSSE();
});

document.getElementById('filterStream').addEventListener('change', applyFilters);

// Search with debounced server lookup for message IDs
let searchTimeout = null;
document.getElementById('filterSearch').addEventListener('input', () => {
  applyFilters();
  clearTimeout(searchTimeout);
  const q = document.getElementById('filterSearch').value.trim();
  if (q.length >= 8) {
    searchTimeout = setTimeout(() => searchMessageById(q), 500);
  }
});

// --- Init ---
async function init() {
  initScrollListener();
  await loadHistory();
  await loadStats();
  connectSSE();
  pollInfrastructure();
  setInterval(tickThroughput, 1000);
  setInterval(() => { loadStats(); pollInfrastructure(); }, 5000);
  drawSparkline();
}
init();
</script>
</body>
</html>
